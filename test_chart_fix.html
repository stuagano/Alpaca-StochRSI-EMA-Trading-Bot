<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Fix Test - TradingView Integration</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            margin: 0;
            padding: 20px;
            background: #0a0e1a;
            color: white;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #00ff88, #1f6feb);
            border-radius: 12px;
            color: #000;
            font-weight: bold;
        }
        .chart-container {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }
        .chart-wrapper {
            height: 500px;
            margin: 20px 0;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status.success {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }
        .status.error {
            background: rgba(255, 107, 53, 0.2);
            border: 1px solid #ff6b35;
            color: #ff6b35;
        }
        .status.info {
            background: rgba(31, 111, 235, 0.2);
            border: 1px solid #1f6feb;
            color: #1f6feb;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        button:hover {
            background: #00cc6a;
            transform: translateY(-2px);
        }
        .log {
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìà Chart Fix Test</h1>
            <p>Testing TradingView Lightweight Charts v4.1.3 Integration</p>
        </div>
        
        <div id="status" class="status info">Initializing chart test...</div>
        
        <div class="controls">
            <button onclick="testChartCreation()">Test Chart Creation</button>
            <button onclick="testWithAPIData()">Test with API Data</button>
            <button onclick="testWithSampleData()">Test Sample Data</button>
            <button onclick="testRealTimeUpdate()">Test Real-time</button>
            <button onclick="clearLog()">Clear Log</button>
        </div>
        
        <div class="chart-container">
            <h3 style="color: #00ff88; margin-bottom: 15px;">Live Candlestick Chart</h3>
            <div id="tradingChart" class="chart-wrapper"></div>
        </div>
        
        <div class="chart-container">
            <h3 style="color: #00ff88; margin-bottom: 15px;">Diagnostic Log</h3>
            <div id="diagnosticLog" class="log"></div>
        </div>
    </div>

    <script>
        let chart = null;
        let candlestickSeries = null;
        let currentSymbol = 'AAPL';
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('diagnosticLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}\n`;
            logDiv.textContent += logEntry;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }
        
        function setStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
        
        function waitForLibraryAndInitialize() {
            if (typeof LightweightCharts !== 'undefined') {
                log('‚úÖ LightweightCharts library loaded');
                log(`üìö Library version: ${LightweightCharts.version || 'Unknown'}`);
                
                // Show available methods
                const methods = Object.getOwnPropertyNames(LightweightCharts);
                log(`üîß Available methods: ${methods.join(', ')}`);
                
                setStatus('‚úÖ Library loaded successfully', 'success');
                
            } else {
                log('‚è≥ Waiting for LightweightCharts library...');
                setTimeout(waitForLibraryAndInitialize, 100);
            }
        }
        
        function testChartCreation() {
            log('üöÄ Testing chart creation...');
            setStatus('Testing chart creation...', 'info');
            
            try {
                const chartContainer = document.getElementById('tradingChart');
                
                // Clear any existing chart
                if (chart) {
                    chart.remove();
                    chart = null;
                    candlestickSeries = null;
                }
                chartContainer.innerHTML = '';
                
                // Create chart
                chart = LightweightCharts.createChart(chartContainer, {
                    width: chartContainer.offsetWidth,
                    height: 500,
                    layout: {
                        backgroundColor: '#1a1a1a',
                        textColor: '#ffffff',
                        fontSize: 12
                    },
                    grid: {
                        vertLines: { color: '#333' },
                        horzLines: { color: '#333' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#555',
                        scaleMargins: { top: 0.1, bottom: 0.1 },
                    },
                    timeScale: {
                        borderColor: '#555',
                        timeVisible: true,
                        secondsVisible: false,
                    },
                });
                
                log('‚úÖ Chart container created');
                
                // Create candlestick series
                candlestickSeries = chart.addCandlestickSeries({
                    upColor: '#00ff88',
                    downColor: '#ff6b35',
                    borderUpColor: '#00ff88',
                    borderDownColor: '#ff6b35',
                    wickUpColor: '#00ff88',
                    wickDownColor: '#ff6b35',
                    borderVisible: false,
                });
                
                log('‚úÖ Candlestick series created');
                log(`üîß Series methods: ${Object.getOwnPropertyNames(candlestickSeries.__proto__).join(', ')}`);
                
                setStatus('‚úÖ Chart creation successful', 'success');
                
            } catch (error) {
                log(`‚ùå Chart creation failed: ${error.message}`);
                setStatus(`‚ùå Chart creation failed: ${error.message}`, 'error');
            }
        }
        
        function testWithSampleData() {
            if (!candlestickSeries) {
                log('‚ùå Chart not created yet. Please run chart creation test first.');
                setStatus('‚ùå Chart not ready', 'error');
                return;
            }
            
            log('üìä Testing with sample data...');
            setStatus('Loading sample data...', 'info');
            
            try {
                const sampleData = generateSampleData(100);
                candlestickSeries.setData(sampleData);
                
                log(`‚úÖ Sample data loaded: ${sampleData.length} candles`);
                setStatus(`‚úÖ Sample data loaded: ${sampleData.length} candles`, 'success');
                
                // Add sample markers for buy/sell signals
                const markers = generateSampleMarkers(sampleData);
                candlestickSeries.setMarkers(markers);
                log(`üìç Added ${markers.length} sample markers`);
                
            } catch (error) {
                log(`‚ùå Sample data failed: ${error.message}`);
                setStatus(`‚ùå Sample data failed: ${error.message}`, 'error');
            }
        }
        
        async function testWithAPIData() {
            if (!candlestickSeries) {
                log('‚ùå Chart not created yet. Please run chart creation test first.');
                setStatus('‚ùå Chart not ready', 'error');
                return;
            }
            
            log('üåê Testing with API data...');
            setStatus('Loading API data...', 'info');
            
            const endpoints = [
                `/api/v2/chart-data/${currentSymbol}?timeframe=15Min&limit=100`,
                `/api/chart/${currentSymbol}?timeframe=15Min&limit=100`,
                `/api/chart-test/${currentSymbol}`
            ];
            
            for (let i = 0; i < endpoints.length; i++) {
                try {
                    log(`üì° Trying endpoint ${i + 1}/${endpoints.length}: ${endpoints[i]}`);
                    
                    const response = await fetch(endpoints[i]);
                    const data = await response.json();
                    
                    if (data.success) {
                        log(`‚úÖ API response received: ${JSON.stringify(data).substring(0, 200)}...`);
                        
                        let chartData = null;
                        
                        // Handle different response formats
                        if (data.candlestick_data && Array.isArray(data.candlestick_data)) {
                            chartData = data.candlestick_data.map(item => ({
                                time: Math.floor(new Date(item.timestamp || item.time).getTime() / 1000),
                                open: parseFloat(item.open),
                                high: parseFloat(item.high),
                                low: parseFloat(item.low),
                                close: parseFloat(item.close)
                            }));
                        } else if (data.data && Array.isArray(data.data)) {
                            if (data.data[0] && data.data[0].data) {
                                chartData = data.data[0].data;
                            } else {
                                chartData = data.data;
                            }
                        }
                        
                        if (chartData && chartData.length > 0) {
                            candlestickSeries.setData(chartData);
                            log(`‚úÖ API data loaded: ${chartData.length} candles`);
                            setStatus(`‚úÖ API data loaded: ${chartData.length} candles`, 'success');
                            return;
                        }
                    } else {
                        log(`‚ùå API returned error: ${data.error || 'Unknown error'}`);
                    }
                    
                } catch (error) {
                    log(`‚ùå Endpoint ${i + 1} failed: ${error.message}`);
                }
            }
            
            log('‚ùå All API endpoints failed, falling back to sample data');
            setStatus('‚ùå API failed, using sample data', 'error');
            testWithSampleData();
        }
        
        function testRealTimeUpdate() {
            if (!candlestickSeries) {
                log('‚ùå Chart not created yet. Please run chart creation test first.');
                return;
            }
            
            log('üîÑ Starting real-time update test...');
            setStatus('Testing real-time updates...', 'info');
            
            let updateCount = 0;
            const interval = setInterval(() => {
                try {
                    const newCandle = generateLatestCandle();
                    candlestickSeries.update(newCandle);
                    updateCount++;
                    
                    if (updateCount % 5 === 0) {
                        log(`üìà Real-time update ${updateCount}: ${newCandle.close}`);
                    }
                    
                    if (updateCount >= 20) {
                        clearInterval(interval);
                        log('‚úÖ Real-time update test completed');
                        setStatus('‚úÖ Real-time test completed', 'success');
                    }
                } catch (error) {
                    log(`‚ùå Real-time update failed: ${error.message}`);
                    clearInterval(interval);
                    setStatus('‚ùå Real-time test failed', 'error');
                }
            }, 500);
        }
        
        function generateSampleData(count) {
            const data = [];
            let basePrice = 150.0;
            const currentTime = Math.floor(Date.now() / 1000);
            
            for (let i = 0; i < count; i++) {
                const time = currentTime - (count - i) * 900; // 15-minute intervals
                
                const priceChange = (Math.random() - 0.5) * 4;
                const open = basePrice + priceChange;
                const high = open + Math.abs(Math.random() * 3);
                const low = open - Math.abs(Math.random() * 3);
                const close = low + (high - low) * Math.random();
                
                data.push({
                    time: time,
                    open: parseFloat(open.toFixed(2)),
                    high: parseFloat(high.toFixed(2)),
                    low: parseFloat(low.toFixed(2)),
                    close: parseFloat(close.toFixed(2))
                });
                
                basePrice = close;
            }
            
            return data;
        }
        
        function generateSampleMarkers(data) {
            const markers = [];
            data.forEach((candle, index) => {
                if (index > 10 && Math.random() < 0.1) {
                    const isBuy = Math.random() > 0.5;
                    markers.push({
                        time: candle.time,
                        position: isBuy ? 'belowBar' : 'aboveBar',
                        color: isBuy ? '#00ff88' : '#ff6b35',
                        shape: isBuy ? 'arrowUp' : 'arrowDown',
                        text: isBuy ? 'BUY' : 'SELL'
                    });
                }
            });
            return markers;
        }
        
        function generateLatestCandle() {
            const currentTime = Math.floor(Date.now() / 1000);
            const basePrice = 150 + (Math.random() - 0.5) * 20;
            
            const open = basePrice;
            const high = open + Math.random() * 3;
            const low = open - Math.random() * 3;
            const close = low + (high - low) * Math.random();
            
            return {
                time: currentTime,
                open: parseFloat(open.toFixed(2)),
                high: parseFloat(high.toFixed(2)),
                low: parseFloat(low.toFixed(2)),
                close: parseFloat(close.toFixed(2))
            };
        }
        
        function clearLog() {
            document.getElementById('diagnosticLog').textContent = '';
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (chart) {
                const container = document.getElementById('tradingChart');
                chart.applyOptions({ width: container.offsetWidth });
            }
        });
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            log('üöÄ Chart Fix Test initialized');
            setStatus('Initializing...', 'info');
            waitForLibraryAndInitialize();
        });
    </script>
</body>
</html>