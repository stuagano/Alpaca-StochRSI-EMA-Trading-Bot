🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
   1: """
   2: High-Frequency Crypto Day Trading Strategy
   3: Focuses on volatility, quick gains, and rapid position turnover
   4: WITH COMPREHENSIVE ERROR HANDLING AND TRADE LOGGING
   5: """
   6: 
   7: import numpy as np
   8: import pandas as pd
   9: import asyncio
  10: import websocket
  11: import json
  12: import math
  13: import time
  14: import os
  15: from dataclasses import dataclass, asdict
  16: from datetime import datetime, timedelta
  17: from decimal import Decimal, ROUND_DOWN
  18: from typing import Dict, List, Optional, Tuple, Any
  19: from concurrent.futures import ThreadPoolExecutor
  20: import logging
  21: from threading import Lock
  22: from enum import Enum
  23: from alpaca.common.exceptions import APIError
  24: 
  25: from utils.trade_store import TradeStore
  26: 
  27: try:
  28:     from prometheus_client import Counter, Gauge  # type: ignore
  29: except ImportError:  # pragma: no cover - optional dependency
  30:     Counter = Gauge = None  # type: ignore[assignment]
  31: 
  32: 
  33: SCANNER_SCAN_METRIC_NAME = "crypto_scanner_scans_total"
  34: SCANNER_ERROR_METRIC_NAME = "crypto_scanner_errors_total"
  35: SCANNER_TRACKED_SYMBOLS_METRIC_NAME = "crypto_scanner_tracked_pairs"
  36: SCANNER_SIGNALS_METRIC_NAME = "crypto_scanner_signals_last"
  37: SCANNER_LAST_RUN_METRIC_NAME = "crypto_scanner_last_run_timestamp"
  38: 
  39: SCANNER_SCAN_COUNTER = Counter(
  40:     SCANNER_SCAN_METRIC_NAME,
  41:     "Total number of crypto scanner runs",
  42: ) if Counter else None
  43: 
  44: SCANNER_ERROR_COUNTER = Counter(
  45:     SCANNER_ERROR_METRIC_NAME,
  46:     "Total number of crypto scanner errors",
  47: ) if Counter else None
  48: 
  49: SCANNER_TRACKED_SYMBOLS_GAUGE = Gauge(
  50:     SCANNER_TRACKED_SYMBOLS_METRIC_NAME,
  51:     "Number of symbols currently tracked by the crypto scanner",
  52: ) if Gauge else None
  53: 
  54: SCANNER_SIGNALS_GAUGE = Gauge(
  55:     SCANNER_SIGNALS_METRIC_NAME,
  56:     "Number of signals generated by the most recent crypto scan",
  57: ) if Gauge else None
  58: 
  59: SCANNER_LAST_RUN_GAUGE = Gauge(
  60:     SCANNER_LAST_RUN_METRIC_NAME,
  61:     "Unix timestamp of the most recent crypto scanner run",
  62: ) if Gauge else None
  63: 
  64: 
  65: def _metric_inc(metric: Optional[Counter], amount: float = 1.0) -> None:
  66:     """Increase a Prometheus counter when available."""
  67: 
  68:     if metric is None:
  69:         return
  70: 
  71:     try:
  72:         metric.inc(amount)
  73:     except Exception:  # pragma: no cover - defensive guard
  74:         logging.getLogger(__name__).debug("Failed to increment metric", exc_info=True)
  75: 
  76: 
  77: def _metric_set(metric: Optional[Gauge], value: float) -> None:
  78:     """Set a Prometheus gauge when available."""
  79: 
  80:     if metric is None:
  81:         return
  82: 
  83:     try:
  84:         metric.set(value)
  85:     except Exception:  # pragma: no cover - defensive guard
  86:         logging.getLogger(__name__).debug("Failed to set metric", exc_info=True)
  87: 
  88: # Configure structured logging
  89: logging.basicConfig(
  90:     level=logging.INFO,
  91:     format='%(asctime)s | %(levelname)-8s | %(message)s',
  92:     datefmt='%Y-%m-%d %H:%M:%S'
  93: )
  94: logger = logging.getLogger(__name__)
  95: 
  96: @dataclass
  97: class TradeLog:
  98:     """Comprehensive trade log entry with all required fields"""
  99:     timestamp: str
 100:     action: str  # 'BUY' or 'SELL'
 101:     symbol: str
 102:     quantity: float
 103:     price: float
 104:     status: str  # 'filled', 'partially_filled', 'failed'
 105:     error_notes: str = ""
 106:     order_id: str = ""
 107:     pnl: float = 0.0
 108:     execution_time_ms: int = 0
 109: 
 110:     def to_console_string(self) -> str:
 111:         """Format for clear console output"""
 112:         status_emoji = {
 113:             "filled": "✅",
 114:             "partially_filled": "⚠️",
 115:             "failed": "❌",
 116:             "pending": "⏳"
 117:         }.get(self.status, "❓")
 118: 
 119:         action_color = "\033[92m" if self.action == "BUY" else "\033[91m"
 120:         reset_color = "\033[0m"
 121: 
 122:         return (
 123:             f"{status_emoji} {self.timestamp} | "
 124:             f"{action_color}{self.action:4s}{reset_color} | "
 125:             f"{self.symbol:10s} | "
 126:             f"Qty: {self.quantity:8.4f} | "
 127:             f"Price: ${self.price:10.2f} | "
 128:             f"Status: {self.status:15s} | "
 129:             f"P&L: ${self.pnl:+8.2f} | "
 130:             f"Exec: {self.execution_time_ms}ms | "
 131:             f"{self.error_notes}"
 132:         )
 133: 
 134: @dataclass
 135: class CryptoSignal:
 136:     symbol: str
 137:     action: str  # 'buy', 'sell', 'hold'
 138:     confidence: float
 139:     price: float
 140:     volatility: float
 141:     volume_surge: bool
 142:     momentum: float
 143:     target_profit: float
 144:     stop_loss: float
 145:     timestamp: datetime
 146: 
 147: class CryptoVolatilityScanner:
 148:     """Scans for high volatility crypto pairs suitable for day trading"""
 149: 
 150:     def __init__(self, enabled_symbols=None):
 151:         # Default verified crypto pairs if no dynamic list provided
 152:         self.default_pairs = [
 153:             # Major pairs - confirmed working
 154:             'BTCUSD', 'ETHUSD', 'LTCUSD', 'BCHUSD',
 155:             # DeFi tokens - verified
 156:             'UNIUSD', 'LINKUSD', 'AAVEUSD', 'MKRUSD',
 157:             # Layer 1 blockchains - verified
 158:             'SOLUSD', 'AVAXUSD', 'ADAUSD', 'DOTUSD', 'MATICUSD',
 159:             # Meme coins & popular - verified
 160:             'DOGEUSD', 'SHIBUSD',
 161:             # Additional liquid pairs - removing ATOMUSD as it caused errors
 162:             'XRPUSD', 'XLMUSD', 'ALGOUSD',
 163:             # Stablecoins trading pairs
 164:             'BTCUSDT', 'ETHUSDT', 'BTCUSDC', 'ETHUSDC'
 165:         ]
 166: 
 167:         # Use provided enabled symbols or fall back to defaults
 168:         self.high_volume_pairs = enabled_symbols or self.default_pairs
 169:         self.enabled_trading_symbols = set(enabled_symbols) if enabled_symbols else set(self.default_pairs)
 170:         _metric_set(SCANNER_TRACKED_SYMBOLS_GAUGE, float(len(self.high_volume_pairs)))
 171: 
 172:         # EXTREMELY AGGRESSIVE criteria for crypto scalping
 173:         self.min_24h_volume = 100000    # $100K daily volume (ultra low for more opportunities)
 174:         self.min_volatility = 0.0001    # 0.01% price movement (ULTRA AGGRESSIVE for scalping)
 175:         self.max_spread = 0.01          # 1% bid-ask spread (very high tolerance)
 176: 
 177:         self.price_data = {}
 178:         self.volatility_data = {}
 179:         self.volume_data = {}
 180:         self.lock = Lock()
 181: 
 182:     def update_enabled_symbols(self, enabled_symbols: List[str]):
 183:         """Update the list of symbols enabled for trading"""
 184:         with self.lock:
 185:             self.enabled_trading_symbols = set(enabled_symbols)
 186:             # Set high_volume_pairs to the new enabled symbols
 187:             self.high_volume_pairs = enabled_symbols.copy()
 188:             logger.info(f"Updated enabled trading symbols: {len(self.enabled_trading_symbols)} symbols")
 189:             logger.info(f"Scanner now tracking {len(self.high_volume_pairs)} high volume pairs: {self.high_volume_pairs}")
 190:             _metric_set(SCANNER_TRACKED_SYMBOLS_GAUGE, float(len(self.high_volume_pairs)))
 191: 
 192:     def get_enabled_symbols(self) -> List[str]:
 193:         """Get list of currently enabled trading symbols"""
 194:         with self.lock:
 195:             return list(self.enabled_trading_symbols)
 196: 
 197:     def fetch_all_crypto_assets(self, api) -> List[str]:
 198:         """Fetch all available crypto assets from Alpaca"""
 199:         try:
 200:             from alpaca.trading.requests import GetAssetsRequest
 201:             from alpaca.trading.enums import AssetClass, AssetStatus
 202: 
 203:             # Create request for crypto assets
 204:             search_params = GetAssetsRequest(
 205:                 status=AssetStatus.ACTIVE,
 206:                 asset_class=AssetClass.CRYPTO
 207:             )
 208: 
 209:             # Get all crypto assets
 210:             assets = api.get_all_assets(search_params)
 211: 
 212:             # Filter for USD pairs and extract symbols
 213:             crypto_symbols = []
 214:             for asset in assets:
 215:                 symbol = asset.symbol
 216:                 # Only include USD pairs for trading
 217:                 if symbol.endswith('USD') and len(symbol) <= 8:  # Reasonable symbol length
 218:                     crypto_symbols.append(symbol)
 219: 
 220:             logger.info(f"📡 Fetched {len(crypto_symbols)} crypto assets from Alpaca")
 221:             return sorted(crypto_symbols)
 222: 
 223:         except Exception as e:
 224:             logger.error(f"Failed to fetch crypto assets: {e}")
 225:             # Fallback to default pairs
 226:             return self.default_pairs
 227: 
 228:     def calculate_market_volatility(self, api, symbols: List[str], lookback_hours: int = 24) -> Dict[str, float]:
 229:         """Calculate 24h volatility for all symbols using Alpaca data client"""
 230:         volatility_scores = {}
 231: 
 232:         try:
 233:             from alpaca.data.historical import CryptoHistoricalDataClient
 234:             from alpaca.data.requests import CryptoBarsRequest
 235:             from alpaca.data.timeframe import TimeFrame, TimeFrameUnit
 236:             from datetime import datetime, timedelta
 237: 
 238:             # Create data client (free tier, no auth needed for crypto data)
 239:             data_client = CryptoHistoricalDataClient()
 240: 
 241:             # Calculate timeframe
 242:             end_time = datetime.now()
 243:             start_time = end_time - timedelta(hours=lookback_hours)
 244: 
 245:             for symbol in symbols:
 246:                 try:
 247:                     # Create bars request
 248:                     request_params = CryptoBarsRequest(
 249:                         symbol_or_symbols=[symbol],
 250:                         timeframe=TimeFrame(1, TimeFrameUnit.Minute),
 251:                         start=start_time,
 252:                         end=end_time
 253:                     )
 254: 
 255:                     # Get historical bars
 256:                     bars_response = data_client.get_crypto_bars(request_params)
 257: 
 258:                     if symbol not in bars_response.data or len(bars_response.data[symbol]) < 50:
 259:                         continue
 260: 
 261:                     # Extract price data
 262:                     bars = bars_response.data[symbol]
 263:                     prices = [float(bar.close) for bar in bars]
 264: 
 265:                     if len(prices) < 2:
 266:                         continue
 267: 
 268:                     # Calculate price volatility
 269:                     volatility = self.calculate_volatility(prices)
 270: 
 271:                     # Calculate 24h price change percentage
 272:                     price_change_pct = abs((prices[-1] - prices[0]) / prices[0]) * 100
 273: 
 274:                     # Combine volatility metrics (favor both volatility and price movement)
 275:                     combined_score = (volatility * 0.7) + (price_change_pct * 0.3)
 276:                     volatility_scores[symbol] = combined_score
 277: 
 278:                 except Exception as e:
 279:                     logger.debug(f"Could not calculate volatility for {symbol}: {e}")
 280:                     continue
 281: 
 282:         except Exception as e:
 283:             logger.error(f"Failed to create data client: {e}")
 284:             # Fallback to simulated volatility
 285:             for symbol in symbols[:5]:  # Limit to top 5 default symbols
 286:                 volatility_scores[symbol] = np.random.uniform(0.001, 0.01)
 287: 
 288:         return volatility_scores
 289: 
 290:     def select_top_volatile_pairs(self, api, target_count: int = 5) -> List[str]:
 291:         """Dynamically select the most volatile crypto pairs"""
 292:         try:
 293:             # Fetch all available crypto assets
 294:             all_symbols = self.fetch_all_crypto_assets(api)
 295: 
 296:             if not all_symbols:
 297:                 logger.warning("No crypto symbols found, using defaults")
 298:                 return self.default_pairs[:target_count]
 299: 
 300:             # Calculate volatility for all symbols
 301:             logger.info(f"🔍 Analyzing volatility for {len(all_symbols)} crypto pairs...")
 302:             volatility_scores = self.calculate_market_volatility(api, all_symbols)
 303: 
 304:             if not volatility_scores:
 305:                 logger.warning("No volatility data available, using defaults")
 306:                 return self.default_pairs[:target_count]
 307: 
 308:             # Sort by volatility score (highest first)
 309:             sorted_pairs = sorted(volatility_scores.items(), key=lambda x: x[1], reverse=True)
 310: 
 311:             # Select top N most volatile pairs
 312:             top_pairs = [symbol for symbol, score in sorted_pairs[:target_count]]
 313: 
 314:             logger.info(f"🎯 Selected top {len(top_pairs)} volatile crypto pairs:")
 315:             for i, (symbol, score) in enumerate(sorted_pairs[:target_count]):
 316:                 logger.info(f"  {i+1}. {symbol}: Volatility Score {score:.4f}")
 317: 
 318:             return top_pairs
 319: 
 320:         except Exception as e:
 321:             logger.error(f"Failed to select volatile pairs: {e}")
 322:             return self.default_pairs[:target_count]
 323: 
 324:     def calculate_volatility(self, prices: List[float], window: int = 20) -> float:
 325:         """Calculate price volatility using standard deviation"""
 326:         if len(prices) < window:
 327:             return 0.0
 328: 
 329:         returns = np.diff(np.log(prices[-window:]))
 330:         return np.std(returns) * np.sqrt(1440)  # Annualized for 1-minute data
 331: 
 332:     def detect_volume_surge(self, volumes: List[float], window: int = 10) -> bool:
 333:         """Detect if current volume is significantly higher than average"""
 334:         if len(volumes) < window + 1:
 335:             return False
 336: 
 337:         recent_avg = np.mean(volumes[-window-1:-1])
 338:         current_volume = volumes[-1]
 339: 
 340:         return current_volume > recent_avg * 1.1  # Only 10% above average (much more aggressive)
 341: 
 342:     def calculate_momentum(self, prices: List[float], period: int = 14) -> float:
 343:         """Calculate price momentum using RSI-like indicator"""
 344:         if len(prices) < period + 1:
 345:             return 0.5
 346: 
 347:         changes = np.diff(prices[-period-1:])
 348:         gains = np.where(changes > 0, changes, 0)
 349:         losses = np.where(changes < 0, -changes, 0)
 350: 
 351:         avg_gain = np.mean(gains)
 352:         avg_loss = np.mean(losses)
 353: 
 354:         if avg_loss == 0:
 355:             return 1.0
 356: 
 357:         rs = avg_gain / avg_loss
 358:         momentum = rs / (1 + rs)
 359: 
 360:         return momentum
 361: 
 362:     def scan_for_opportunities(self) -> List[CryptoSignal]:
 363:         """Scan all crypto pairs for day trading opportunities - ULTRA AGGRESSIVE MODE"""
 364:         signals = []
 365: 
 366:         with self.lock:
 367:             _metric_inc(SCANNER_SCAN_COUNTER)
 368:             _metric_set(SCANNER_LAST_RUN_GAUGE, float(time.time()))
 369:             _metric_set(SCANNER_TRACKED_SYMBOLS_GAUGE, float(len(self.high_volume_pairs)))
 370:             logger.info(f"🔍 Scanning {len(self.high_volume_pairs)} symbols for opportunities...")
 371: 
 372:             # DEBUG: Print all available price data keys
 373:             logger.info(f"📊 Price data available for: {list(self.price_data.keys())}")
 374:             logger.info(f"📊 Expected symbols: {self.high_volume_pairs}")
 375: 
 376:             for symbol in self.high_volume_pairs:
 377:                 try:
 378:                     if symbol not in self.price_data:
 379:                         logger.info(f"  ❌ {symbol}: No price data available")
 380:                         continue
 381: 
 382:                     prices = self.price_data[symbol]
 383:                     volumes = self.volume_data.get(symbol, [])
 384: 
 385:                     if len(prices) < 2:  # MINIMAL requirement for ultra-fast signals
 386:                         logger.info(f"  ❌ {symbol}: Insufficient price data ({len(prices)} points)")
 387:                         continue
 388: 
 389:                     current_price = prices[-1]
 390:                     volatility = self.calculate_volatility(prices)
 391:                     volume_surge = self.detect_volume_surge(volumes)
 392:                     momentum = self.calculate_momentum(prices)
 393: 
 394:                     logger.info(f"  📊 {symbol}: Price=${current_price:.4f}, Vol={volatility:.6f}, Mom={momentum:.3f}, Surge={volume_surge}")
 395: 
 396:                     # REMOVED VOLATILITY FILTER - Generate signals for ANY volatility!
 397:                     # Original filter was: if volatility < self.min_volatility: continue
 398: 
 399:                     # Generate trading signal
 400:                     signal = self._generate_signal(
 401:                         symbol, current_price, volatility,
 402:                         volume_surge, momentum
 403:                     )
 404: 
 405:                     if signal:
 406:                         signals.append(signal)
 407:                         logger.info(f"  ✅ {symbol}: Generated {signal.action.upper()} signal (confidence: {signal.confidence:.3f})")
 408:                     else:
 409:                         logger.info(f"  ❌ {symbol}: No signal generated (signal was None)")
 410: 
 411:                 except Exception as e:
 412:                     logger.error(f"Error scanning {symbol}: {e}")
 413:                     _metric_inc(SCANNER_ERROR_COUNTER)
 414: 
 415:         logger.info(f"🎯 Total signals generated: {len(signals)}")
 416:         # Sort by best opportunities (high volatility + volume surge)
 417:         top_signals = sorted(signals, key=lambda s: s.confidence, reverse=True)[:10]
 418:         _metric_set(SCANNER_SIGNALS_GAUGE, float(len(top_signals)))
 419:         return top_signals
 420: 
 421:     def _generate_signal(self, symbol: str, price: float, volatility: float,
 422:                         volume_surge: bool, momentum: float) -> Optional[CryptoSignal]:
 423:         """Generate trading signal based on analysis"""
 424: 
 425:         # ULTRA AGGRESSIVE scalping thresholds for crypto
 426:         high_momentum_threshold = 0.55     # Very low threshold for more trades
 427:         low_momentum_threshold = 0.45      # Very tight range for more opportunities
 428:         high_volatility_threshold = 0.001  # 0.1% instead of 1% (10x more aggressive)
 429: 
 430:         # Determine action
 431:         action = 'hold'
 432:         confidence = 0.0
 433:         target_profit = 0.005  # Default 0.5% profit target
 434:         stop_loss = 0.003      # Default 0.3% stop loss
 435: 
 436:         # High volatility + momentum signals
 437:         if volatility > high_volatility_threshold:
 438:             target_profit = 0.008  # 0.8% profit for high volatility
 439:             stop_loss = 0.005      # 0.5% stop loss
 440: 
 441:             if momentum > high_momentum_threshold:
 442:                 action = 'buy'
 443:                 confidence = min(0.9, volatility * 10 + (0.3 if volume_surge else 0))
 444:             elif momentum < low_momentum_threshold:
 445:                 action = 'sell'
 446:                 confidence = min(0.9, volatility * 10 + (0.3 if volume_surge else 0))
 447: 
 448:         # ULTRA AGGRESSIVE volatility signals - REMOVED volatility requirement entirely!
 449:         elif True:  # Always generate signals regardless of volatility!
 450:             if momentum > 0.52 and volume_surge:  # Much lower threshold
 451:                 action = 'buy'
 452:                 confidence = 0.9  # Even higher confidence
 453:             elif momentum < 0.48 and volume_surge:  # Much tighter range
 454:                 action = 'sell'
 455:                 confidence = 0.9  # Even higher confidence
 456:             # Add signals without volume surge requirement (VERY AGGRESSIVE)
 457:             elif momentum > 0.52:  # Any momentum above neutral
 458:                 action = 'buy'
 459:                 confidence = 0.8  # Higher confidence
 460:             elif momentum < 0.48:  # Any momentum below neutral
 461:                 action = 'sell'
 462:                 confidence = 0.8  # Higher confidence
 463:             # EVEN MORE AGGRESSIVE: Generate signals for ANY momentum deviation
 464:             elif momentum > 0.51:  # TINY deviation above neutral
 465:                 action = 'buy'
 466:                 confidence = 0.7
 467:             elif momentum < 0.49:  # TINY deviation below neutral
 468:                 action = 'sell'
 469:                 confidence = 0.7
 470: 
 471:         # ULTRA AGGRESSIVE volume surge signals
 472:         if volume_surge and action == 'hold':
 473:             if momentum > 0.51:  # Almost any bullish momentum
 474:                 action = 'buy'
 475:                 confidence = 0.9     # Very high confidence
 476:                 target_profit = 0.004  # Quick 0.4% target
 477:                 stop_loss = 0.002      # Tight 0.2% stop
 478:             elif momentum < 0.49:    # Almost any bearish momentum
 479:                 action = 'sell'
 480:                 confidence = 0.9     # Very high confidence
 481:                 target_profit = 0.004
 482:                 stop_loss = 0.002
 483: 
 484:         # MAXIMUM AGGRESSION: Generate signals for ANY price movement!
 485:         if action == 'hold':  # No volatility requirement - trade everything!
 486:             if momentum > 0.505:  # ULTRA minimal bullish momentum (0.5% above neutral)
 487:                 action = 'buy'
 488:                 confidence = 0.9   # Very high confidence for maximum execution
 489:                 target_profit = 0.003
 490:                 stop_loss = 0.0015
 491:             elif momentum < 0.495:  # ULTRA minimal bearish momentum (0.5% below neutral)
 492:                 action = 'sell'
 493:                 confidence = 0.9   # Very high confidence for maximum execution
 494:                 target_profit = 0.003
 495:                 stop_loss = 0.0015
 496:             # FINAL FALLBACK: If absolutely no momentum, still try to trade on volatility
 497:             elif volatility > 0.0001:  # ANY volatility at all
 498:                 import random
 499:                 action = 'buy' if random.random() > 0.5 else 'sell'  # Random direction
 500:                 confidence = 0.6  # Medium confidence for fallback trades
 501:                 target_profit = 0.002
 502:                 stop_loss = 0.001
 503: 
 504:         # ULTRA AGGRESSIVE: Accept ANY signal with ANY confidence > 0.01 (1%)
 505:         if action != 'hold' and confidence > 0.01:  # EXTREMELY LOW threshold - almost any signal
 506:             logger.info(f"    🎯 Creating signal: {action.upper()} {symbol} conf={confidence:.3f} vol={volatility:.6f}")
 507:             return CryptoSignal(
 508:                 symbol=symbol,
 509:                 action=action,
 510:                 confidence=confidence,
 511:                 price=price,
 512:                 volatility=volatility,
 513:                 volume_surge=volume_surge,
 514:                 momentum=momentum,
 515:                 target_profit=target_profit,
 516:                 stop_loss=stop_loss,
 517:                 timestamp=datetime.now()
 518:             )
 519:         else:
 520:             logger.info(f"    ❌ Signal rejected: action={action}, confidence={confidence:.3f} (< 0.01)")
 521: 
 522:         return None
 523: 
 524:     def update_market_data(self, symbol: str, price: float, volume: float):
 525:         """Update real-time market data"""
 526:         with self.lock:
 527:             if symbol not in self.price_data:
 528:                 self.price_data[symbol] = []
 529:                 self.volume_data[symbol] = []
 530: 
 531:             self.price_data[symbol].append(price)
 532:             self.volume_data[symbol].append(volume)
 533: 
 534:             # Keep only recent data (1000 data points ≈ 16-17 hours of 1-min data)
 535:             if len(self.price_data[symbol]) > 1000:
 536:                 self.price_data[symbol] = self.price_data[symbol][-1000:]
 537:                 self.volume_data[symbol] = self.volume_data[symbol][-1000:]
 538: 
 539: class CryptoDayTradingBot:
 540:     CASH_SAFETY_BUFFER = Decimal('0.995')
 541:     DEFAULT_TICK_SIZE = Decimal('0.000001')
 542:     TICK_SIZE_BY_SYMBOL = {
 543:         'BTC': Decimal('0.000001'),  # 1e-6 BTC
 544:         'ETH': Decimal('0.0001'),    # 1e-4 ETH
 545:     }
 546:     """High-frequency crypto day trading bot with comprehensive error handling"""
 547: 
 548:     def __init__(self, alpaca_client, initial_capital: float = 10000):
 549:         self.alpaca = alpaca_client
 550:         self.scanner = CryptoVolatilityScanner()
 551:         self.initial_capital = initial_capital
 552:         self.max_position_size = min(100, initial_capital * 0.01)  # 1% per trade, max $100
 553:         self.max_concurrent_positions = 10
 554:         self.min_profit_target = 0.003  # 0.3% minimum profit
 555: 
 556:         # Trading metrics
 557:         self.active_positions = {}
 558:         self.daily_trades = 0
 559:         self.daily_profit = 0.0
 560:         self.win_rate = 0.0
 561:         self.total_trades = 0
 562:         self.wins = 0
 563: 
 564:         # Risk management
 565:         self.max_daily_loss = initial_capital * 0.02  # 2% daily loss limit
 566:         self.max_drawdown = initial_capital * 0.05    # 5% maximum drawdown
 567: 
 568:         # Error handling
 569:         self.error_count = 0
 570:         self.max_errors = 10
 571:         self.reconnect_attempts = 0
 572:         self.max_reconnect_attempts = 5
 573:         self.rate_limit_errors = 0
 574:         self.last_rate_limit_time = None
 575: 
 576:         # Trade logging
 577:         self.trade_log: List[TradeLog] = []
 578:         self.log_file = 'logs/crypto_trade_timeline.log'
 579:         os.makedirs('logs', exist_ok=True)
 580: 
 581:         self.is_running = False
 582:         self.executor = ThreadPoolExecutor(max_workers=5)
 583: 
 584:     async def start_trading(self):
 585:         """Start the day trading bot"""
 586:         logger.info("🚀 Starting Crypto Day Trading Bot")
 587:         self.is_running = True
 588: 
 589:         # Start market data feed
 590:         self.executor.submit(self._start_market_data_feed)
 591: 
 592:         # Main trading loop
 593:         while self.is_running:
 594:             try:
 595:                 await self._trading_cycle()
 596:                 await asyncio.sleep(1)  # 1-second cycle for high frequency
 597: 
 598:             except Exception as e:
 599:                 logger.error(f"Trading cycle error: {e}")
 600:                 await asyncio.sleep(5)
 601: 
 602:     async def _trading_cycle(self):
 603:         """Main trading cycle - runs every second"""
 604: 
 605:         # Check for exit signals on existing positions
 606:         await self._check_exit_conditions()
 607: 
 608:         # Look for new entry opportunities every 5 seconds
 609:         if int(time.time()) % 5 == 0:
 610:             await self._find_entry_opportunities()
 611: 
 612:         # Update metrics every minute
 613:         if int(time.time()) % 60 == 0:
 614:             self._update_metrics()
 615: 
 616:     async def _find_entry_opportunities(self):
 617:         """Find new trading opportunities"""
 618:         if len(self.active_positions) >= self.max_concurrent_positions:
 619:             return
 620: 
 621:         if abs(self.daily_profit) > self.max_daily_loss:
 622:             logger.warning("Daily loss limit reached, stopping new trades")
 623:             return
 624: 
 625:         # Get trading signals
 626:         signals = self.scanner.scan_for_opportunities()
 627: 
 628:         for signal in signals[:5]:  # Top 5 opportunities
 629:             if signal.symbol in self.active_positions:
 630:                 continue
 631: 
 632:             if signal.confidence > 0.7:  # High confidence trades only
 633:                 await self._execute_entry(signal)
 634: 
 635:     async def _execute_entry(self, signal: CryptoSignal):
 636:         """Execute entry trade with comprehensive error handling and logging"""
 637:         start_time = time.time()
 638:         trade_log = TradeLog(
 639:             timestamp=datetime.now().isoformat(),
 640:             action=signal.action.upper(),
 641:             symbol=signal.symbol,
 642:             quantity=0,
 643:             price=signal.price,
 644:             status="pending",
 645:             error_notes=""
 646:         )
 647: 
 648:         try:
 649:             # IMPORTANT: Skip SELL signals (no short selling in crypto)
 650:             # Only execute BUY signals
 651:             if signal.action.lower() == 'sell':
 652:                 logger.info(f"⏭️  Skipping SELL signal for {signal.symbol} (no short selling)")
 653:                 return
 654: 
 655:             # Calculate position size - ensure minimum $10 order size
 656:             position_value = max(
 657:                 10.0,  # Alpaca minimum
 658:                 min(self.max_position_size, 25 * signal.confidence)  # Max $25 per trade
 659:             )
 660: 
 661:             # Clamp against available funds with a safety margin
 662:             try:
 663:                 account = self.alpaca.get_account()
 664:                 available_cash = float(getattr(account, 'cash', getattr(account, 'buying_power', 0.0)))
 665:             except Exception as exc:
 666:                 logger.warning(f"Unable to fetch account balance, defaulting to configured limits: {exc}")
 667:                 available_cash = position_value
 668: 
 669:             quantity = self._calculate_affordable_quantity(
 670:                 price=signal.price,
 671:                 desired_notional=position_value,
 672:                 available_cash=available_cash,
 673:                 symbol=signal.symbol,
 674:             )
 675: 
 676:             if quantity <= 0:
 677:                 logger.warning("Calculated crypto quantity is 0 after precision clamp")
 678:                 return
 679: 
 680:             quantity_dec = quantity if isinstance(quantity, Decimal) else Decimal(str(quantity))
 681:             price_dec = Decimal(str(signal.price))
 682: 
 683:             trade_log.quantity = float(quantity_dec)
 684: 
 685:             # Place order with error handling
 686:             order = await self._place_crypto_order_with_retry(
 687:                 symbol=signal.symbol,
 688:                 side=signal.action,
 689:                 quantity=float(quantity_dec),
 690:                 order_type='market'
 691:             )
 692: 
 693:             if order:
 694:                 # Track position
 695:                 self.active_positions[signal.symbol] = {
 696:                     'signal': signal,
 697:                     'entry_price': signal.price,
 698:                     'entry_price_dec': price_dec,
 699:                     'quantity': quantity_dec,
 700:                     'side': signal.action,
 701:                     'entry_time': datetime.now(),
 702:                     'target_price': signal.price * (1 + signal.target_profit) if signal.action == 'buy' else signal.price * (1 - signal.target_profit),
 703:                     'stop_price': signal.price * (1 - signal.stop_loss) if signal.action == 'buy' else signal.price * (1 + signal.stop_loss),
 704:                     'order_id': order.id if hasattr(order, 'id') else str(order)
 705:                 }
 706: 
 707:                 trade_log.status = "filled"
 708:                 trade_log.order_id = order.id if hasattr(order, 'id') else str(order)
 709:                 trade_log.execution_time_ms = int((time.time() - start_time) * 1000)
 710: 
 711:                 logger.info(f"🎯 Opened {signal.action.upper()} position: {signal.symbol} @ {signal.price:.4f}")
 712:             else:
 713:                 trade_log.status = "failed"
 714:                 trade_log.error_notes = "Order placement failed"
 715: 
 716:         except APIError as e:
 717:             trade_log.status = "failed"
 718:             if hasattr(e, 'code'):
 719:                 if e.code == 429:
 720:                     trade_log.error_notes = "API rate limit exceeded"
 721:                     self.rate_limit_errors += 1
 722:                     self.last_rate_limit_time = datetime.now()
 723:                     logger.error(f"🚫 Rate limit hit for {signal.symbol}: {e}")
 724:                     await self._handle_rate_limit()
 725:                 elif e.code == 403:
 726:                     trade_log.error_notes = "Insufficient funds"
 727:                     logger.error(f"💸 Insufficient funds for {signal.symbol}")
 728:                 elif e.code == 400:
 729:                     trade_log.error_notes = f"Invalid request: {str(e)}"
 730:                     logger.error(f"❌ Invalid request for {signal.symbol}: {e}")
 731:                 else:
 732:                     trade_log.error_notes = f"API error {e.code}: {str(e)}"
 733:                     logger.error(f"❌ API error for {signal.symbol}: {e}")
 734:             else:
 735:                 trade_log.error_notes = f"API error: {str(e)}"
 736:                 logger.error(f"❌ API error for {signal.symbol}: {e}")
 737: 
 738:         except ConnectionError as e:
 739:             trade_log.status = "failed"
 740:             trade_log.error_notes = "Connection lost, attempting reconnect"
 741:             logger.error(f"🔌 Connection error for {signal.symbol}: {e}")
 742:             await self._handle_connection_error()
 743: 
 744:         except Exception as e:
 745:             trade_log.status = "failed"
 746:             trade_log.error_notes = f"Unexpected error: {str(e)}"
 747:             logger.error(f"❌ Unexpected error for {signal.symbol}: {e}")
 748:             self.error_count += 1
 749: 
 750:         finally:
 751:             # Log trade to timeline
 752:             trade_log.execution_time_ms = int((time.time() - start_time) * 1000)
 753:             self._log_trade(trade_log)
 754: 
 755:     @classmethod
 756:     def _crypto_tick_size(cls, symbol: str) -> Decimal:
 757:         base = symbol.split('/')[0].upper() if '/' in symbol else symbol.upper()
 758:         return cls.TICK_SIZE_BY_SYMBOL.get(base, cls.DEFAULT_TICK_SIZE)
 759: 
 760:     @classmethod
 761:     def _calculate_affordable_quantity(
 762:         cls,
 763:         *,
 764:         price: float,
 765:         desired_notional: float,
 766:         available_cash: float,
 767:         symbol: str,
 768:     ) -> Decimal:
 769:         price_dec = Decimal(str(price))
 770:         desired_dec = Decimal(str(desired_notional))
 771:         available_dec = Decimal(str(available_cash))
 772: 
 773:         if price_dec <= 0:
 774:             return Decimal('0')
 775: 
 776:         safe_cash = (available_dec * cls.CASH_SAFETY_BUFFER).quantize(Decimal('0.000000001'), rounding=ROUND_DOWN)
 777:         notional_cap = min(desired_dec, safe_cash)
 778:         if notional_cap <= 0:
 779:             return Decimal('0')
 780: 
 781:         raw_qty = notional_cap / price_dec
 782:         tick_size = cls._crypto_tick_size(symbol)
 783:         if tick_size <= 0:
 784:             tick_size = cls.DEFAULT_TICK_SIZE
 785: 
 786:         ticks = (raw_qty / tick_size).to_integral_value(rounding=ROUND_DOWN)
 787:         qty = ticks * tick_size
 788:         if qty < tick_size:
 789:             return Decimal('0')
 790:         return qty
 791: 
 792:     async def _check_exit_conditions(self):
 793:         """Check exit conditions for all active positions"""
 794:         positions_to_close = []
 795: 
 796:         for symbol, position in self.active_positions.items():
 797:             try:
 798:                 # Get current price
 799:                 current_price = await self._get_current_price(symbol)
 800:                 if not current_price:
 801:                     continue
 802: 
 803:                 signal = position['signal']
 804:                 entry_price = position['entry_price']
 805:                 side = position['side']
 806: 
 807:                 # Calculate current P&L
 808:                 if side == 'buy':
 809:                     pnl_pct = (current_price - entry_price) / entry_price
 810:                 else:
 811:                     pnl_pct = (entry_price - current_price) / entry_price
 812: 
 813:                 should_exit = False
 814:                 exit_reason = ""
 815: 
 816:                 # Profit target hit
 817:                 if ((side == 'buy' and current_price >= position['target_price']) or
 818:                     (side == 'sell' and current_price <= position['target_price'])):
 819:                     should_exit = True
 820:                     exit_reason = "PROFIT_TARGET"
 821: 
 822:                 # Stop loss hit
 823:                 elif ((side == 'buy' and current_price <= position['stop_price']) or
 824:                       (side == 'sell' and current_price >= position['stop_price'])):
 825:                     should_exit = True
 826:                     exit_reason = "STOP_LOSS"
 827: 
 828:                 # Time-based exit (hold for max 30 minutes for scalping)
 829:                 elif (datetime.now() - position['entry_time']).seconds > 1800:
 830:                     should_exit = True
 831:                     exit_reason = "TIME_LIMIT"
 832: 
 833:                 # Trailing stop for profitable positions
 834:                 elif pnl_pct > 0.01:  # 1% profit
 835:                     # Implement trailing stop
 836:                     trail_distance = 0.005  # 0.5% trailing distance
 837:                     if side == 'buy':
 838:                         new_stop = current_price * (1 - trail_distance)
 839:                         if new_stop > position['stop_price']:
 840:                             position['stop_price'] = new_stop
 841:                     else:
 842:                         new_stop = current_price * (1 + trail_distance)
 843:                         if new_stop < position['stop_price']:
 844:                             position['stop_price'] = new_stop
 845: 
 846:                 if should_exit:
 847:                     positions_to_close.append((symbol, exit_reason, current_price, pnl_pct))
 848: 
 849:             except Exception as e:
 850:                 logger.error(f"Error checking exit for {symbol}: {e}")
 851: 
 852:         # Close positions
 853:         for symbol, reason, price, pnl_pct in positions_to_close:
 854:             await self._execute_exit(symbol, reason, price, pnl_pct)
 855: 
 856:     async def _execute_exit(self, symbol: str, reason: str, price: float, pnl_pct: float):
 857:         """Execute exit trade"""
 858:         try:
 859:             position = self.active_positions[symbol]
 860: 
 861:             # Place closing order
 862:             opposite_side = 'sell' if position['side'] == 'buy' else 'buy'
 863: 
 864:             order = await self._place_crypto_order(
 865:                 symbol=symbol,
 866:                 side=opposite_side,
 867:                 quantity=position['quantity'],
 868:                 order_type='market'
 869:             )
 870: 
 871:             if order:
 872:                 # Update metrics
 873:         qty_dec = position['quantity'] if isinstance(position['quantity'], Decimal) else Decimal(str(position['quantity']))
 874:         price_dec = Decimal(str(position.get('entry_price_dec') or position['entry_price']))
 875:         profit = float(qty_dec * price_dec * Decimal(str(pnl_pct)))
 876:         self.daily_profit += profit
 877:                 self.total_trades += 1
 878: 
 879:                 if pnl_pct > 0:
 880:                     self.wins += 1
 881: 
 882:                 self.win_rate = self.wins / self.total_trades if self.total_trades > 0 else 0
 883: 
 884:                 # Remove from active positions
 885:                 del self.active_positions[symbol]
 886: 
 887:                 logger.info(f"✅ Closed position: {symbol} | Reason: {reason} | P&L: {pnl_pct:.2%} | Profit: ${profit:.2f}")
 888: 
 889:         except Exception as e:
 890:             logger.error(f"Failed to execute exit for {symbol}: {e}")
 891: 
 892:     async def _place_crypto_order(self, symbol: str, side: str, quantity: float, order_type: str = 'market'):
 893:         """Place crypto order via Alpaca API"""
 894:         try:
 895:             # Convert symbol format if needed (BTC/USD -> BTCUSD)
 896:             alpaca_symbol = symbol.replace('/', '')
 897: 
 898:             # Import order request classes
 899:             from alpaca.trading.requests import MarketOrderRequest
 900:             from alpaca.trading.enums import OrderSide, TimeInForce
 901: 
 902:             # Convert side to enum
 903:             order_side = OrderSide.BUY if side.lower() == 'buy' else OrderSide.SELL
 904: 
 905:             # Create market order request
 906:             order_request = MarketOrderRequest(
 907:                 symbol=alpaca_symbol,
 908:                 qty=quantity,
 909:                 side=order_side,
 910:                 time_in_force=TimeInForce.IOC  # Immediate or cancel for crypto
 911:             )
 912: 
 913:             # Submit order using Alpaca client
 914:             order = self.alpaca.submit_order(order_data=order_request)
 915:             return order
 916: 
 917:         except Exception as e:
 918:             logger.error(f"Order placement failed for {symbol}: {e}")
 919:             return None
 920: 
