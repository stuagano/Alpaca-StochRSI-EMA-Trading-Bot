"""
GitHub Integration Configuration for BMAD

Provides configuration management for GitHub Projects and Wikis integration
with comprehensive validation and security.
"""

import os
import json
import logging
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, asdict
from pathlib import Path

logger = logging.getLogger(__name__)


@dataclass
class GitHubAuthentication:
    """GitHub authentication configuration"""
    token: str
    method: str = "personal_token"  # personal_token, github_app, oauth
    app_id: Optional[str] = None
    app_private_key: Optional[str] = None
    webhook_secret: Optional[str] = None


@dataclass
class GitHubRepository:
    """GitHub repository configuration"""
    owner: str
    name: str
    default_branch: str = "main"
    wiki_enabled: bool = True
    projects_enabled: bool = True


@dataclass
class EpicMapping:
    """Epic to GitHub Project mapping configuration"""
    enabled: bool = True
    auto_create_projects: bool = True
    project_template: str = "EPIC: {epic_name}"
    project_description_template: str = "Epic: {epic_description}\n\nBMAD Phase: {current_phase}"
    default_columns: List[str] = None
    labels: List[str] = None
    
    def __post_init__(self):
        if self.default_columns is None:
            self.default_columns = ["To Do", "In Progress", "Review", "Done"]
        if self.labels is None:
            self.labels = ["epic", "bmad"]


@dataclass
class StoryMapping:
    """Story to GitHub Issue mapping configuration"""
    enabled: bool = True
    auto_create_issues: bool = True
    issue_template: str = "STORY: {story_title}"
    issue_body_template: str = """
## Story Description
{story_description}

## Acceptance Criteria
{acceptance_criteria}

## BMAD Information
- **Epic**: {epic_name}
- **Phase**: {current_phase}
- **Story ID**: {story_id}
- **Priority**: {priority}

## Technical Details
{technical_details}

---
*Generated by BMAD GitHub Integration*
"""
    labels: List[str] = None
    assignee_mapping: Dict[str, str] = None
    milestone_mapping: bool = True
    
    def __post_init__(self):
        if self.labels is None:
            self.labels = ["story", "bmad"]
        if self.assignee_mapping is None:
            self.assignee_mapping = {}


@dataclass
class WikiIntegration:
    """GitHub Wiki integration configuration"""
    enabled: bool = True
    auto_update: bool = True
    epic_page_template: str = "Epic-{epic_id}-{epic_name}"
    story_page_template: str = "Story-{story_id}-{story_title}"
    index_page: str = "BMAD-Project-Index"
    epic_page_content_template: str = """
# Epic: {epic_name}

## Overview
{epic_description}

## Current Status
- **Phase**: {current_phase}
- **Progress**: {progress_percentage}%
- **Start Date**: {start_date}
- **Target Completion**: {target_completion}

## Stories
{stories_list}

## Technical Architecture
{technical_architecture}

## Success Metrics
{success_metrics}

## Dependencies
{dependencies}

## Risk Assessment
{risk_assessment}

---
*Last Updated: {last_updated} via BMAD Integration*
"""
    story_page_content_template: str = """
# Story: {story_title}

## Description
{story_description}

## Epic Context
**Epic**: [{epic_name}]({epic_wiki_link})

## Acceptance Criteria
{acceptance_criteria}

## Technical Implementation
{technical_implementation}

## Testing Strategy
{testing_strategy}

## Definition of Done
{definition_of_done}

## Progress Tracking
- **Status**: {status}
- **Assigned To**: {assignee}
- **Phase**: {current_phase}
- **Last Updated**: {last_updated}

---
*Generated by BMAD GitHub Integration*
"""


@dataclass
class SynchronizationConfig:
    """Synchronization configuration"""
    enabled: bool = True
    bidirectional: bool = True
    real_time_webhook: bool = True
    batch_sync_interval: int = 300  # seconds
    retry_attempts: int = 3
    retry_delay: int = 60  # seconds
    queue_max_size: int = 1000
    webhook_timeout: int = 30


@dataclass
class QualityGates:
    """Quality gates for GitHub integration"""
    enabled: bool = True
    require_epic_approval: bool = True
    require_story_validation: bool = True
    auto_close_completed: bool = True
    sync_validation: bool = True
    error_threshold: int = 10  # Max errors before pausing sync


@dataclass
class Monitoring:
    """Monitoring and observability configuration"""
    enabled: bool = True
    metrics_collection: bool = True
    log_level: str = "INFO"
    health_check_interval: int = 60  # seconds
    performance_tracking: bool = True
    alert_on_failures: bool = True
    webhook_logging: bool = True


@dataclass
class GitHubIntegrationConfig:
    """Complete GitHub integration configuration"""
    authentication: GitHubAuthentication
    repository: GitHubRepository
    epic_mapping: EpicMapping
    story_mapping: StoryMapping
    wiki_integration: WikiIntegration
    synchronization: SynchronizationConfig
    quality_gates: QualityGates
    monitoring: Monitoring
    
    # Integration metadata
    version: str = "1.0.0"
    enabled: bool = True
    last_sync: Optional[str] = None
    sync_statistics: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.sync_statistics is None:
            self.sync_statistics = {
                "total_syncs": 0,
                "successful_syncs": 0,
                "failed_syncs": 0,
                "last_error": None,
                "avg_sync_time": 0.0
            }


class GitHubConfigManager:
    """Manager for GitHub integration configuration"""
    
    def __init__(self, config_path: str = None):
        """
        Initialize configuration manager
        
        Args:
            config_path: Path to configuration file
        """
        if config_path is None:
            config_path = os.getenv("GITHUB_CONFIG_PATH", "config/github_integration.json")
        
        self.config_path = Path(config_path)
        self.config: Optional[GitHubIntegrationConfig] = None
        
        # Load configuration
        self.load_config()
    
    def load_config(self) -> GitHubIntegrationConfig:
        """Load configuration from file"""
        try:
            if self.config_path.exists():
                with open(self.config_path, 'r') as f:
                    config_data = json.load(f)
                self.config = self._dict_to_config(config_data)
                logger.info(f"Loaded GitHub configuration from {self.config_path}")
            else:
                self.config = self._create_default_config()
                self.save_config()
                logger.info(f"Created default GitHub configuration at {self.config_path}")
                
        except Exception as e:
            logger.error(f"Failed to load GitHub configuration: {str(e)}")
            self.config = self._create_default_config()
        
        return self.config
    
    def save_config(self) -> None:
        """Save configuration to file"""
        try:
            self.config_path.parent.mkdir(parents=True, exist_ok=True)
            
            config_dict = self._config_to_dict(self.config)
            
            with open(self.config_path, 'w') as f:
                json.dump(config_dict, f, indent=2, default=str)
            
            logger.info(f"Saved GitHub configuration to {self.config_path}")
            
        except Exception as e:
            logger.error(f"Failed to save GitHub configuration: {str(e)}")
            raise
    
    def update_config(self, updates: Dict[str, Any]) -> None:
        """Update configuration with new values"""
        try:
            config_dict = self._config_to_dict(self.config)
            config_dict.update(updates)
            self.config = self._dict_to_config(config_dict)
            self.save_config()
            
        except Exception as e:
            logger.error(f"Failed to update GitHub configuration: {str(e)}")
            raise
    
    def get_config(self) -> GitHubIntegrationConfig:
        """Get current configuration"""
        if self.config is None:
            self.load_config()
        return self.config
    
    def validate_config(self) -> List[str]:
        """
        Validate configuration
        
        Returns:
            List of validation errors
        """
        errors = []
        
        if not self.config:
            errors.append("Configuration not loaded")
            return errors
        
        # Validate authentication
        auth = self.config.authentication
        if not auth.token:
            errors.append("GitHub token is required")
        
        if auth.method == "github_app":
            if not auth.app_id or not auth.app_private_key:
                errors.append("GitHub App ID and private key are required for app authentication")
        
        # Validate repository
        repo = self.config.repository
        if not repo.owner or not repo.name:
            errors.append("Repository owner and name are required")
        
        # Validate webhook secret if webhooks enabled
        if self.config.synchronization.real_time_webhook and not auth.webhook_secret:
            errors.append("Webhook secret is required when real-time webhooks are enabled")
        
        # Validate templates
        epic_mapping = self.config.epic_mapping
        if epic_mapping.enabled and not epic_mapping.project_template:
            errors.append("Project template is required when epic mapping is enabled")
        
        story_mapping = self.config.story_mapping
        if story_mapping.enabled and not story_mapping.issue_template:
            errors.append("Issue template is required when story mapping is enabled")
        
        return errors
    
    def _create_default_config(self) -> GitHubIntegrationConfig:
        """Create default configuration"""
        return GitHubIntegrationConfig(
            authentication=GitHubAuthentication(
                token=os.getenv("GITHUB_TOKEN", ""),
                webhook_secret=os.getenv("GITHUB_WEBHOOK_SECRET", "")
            ),
            repository=GitHubRepository(
                owner=os.getenv("GITHUB_OWNER", ""),
                name=os.getenv("GITHUB_REPO", "")
            ),
            epic_mapping=EpicMapping(),
            story_mapping=StoryMapping(),
            wiki_integration=WikiIntegration(),
            synchronization=SynchronizationConfig(),
            quality_gates=QualityGates(),
            monitoring=Monitoring()
        )
    
    def _config_to_dict(self, config: GitHubIntegrationConfig) -> Dict[str, Any]:
        """Convert configuration to dictionary"""
        return asdict(config)
    
    def _dict_to_config(self, config_dict: Dict[str, Any]) -> GitHubIntegrationConfig:
        """Convert dictionary to configuration"""
        # Handle nested dataclasses
        auth_data = config_dict.get("authentication", {})
        repo_data = config_dict.get("repository", {})
        epic_data = config_dict.get("epic_mapping", {})
        story_data = config_dict.get("story_mapping", {})
        wiki_data = config_dict.get("wiki_integration", {})
        sync_data = config_dict.get("synchronization", {})
        quality_data = config_dict.get("quality_gates", {})
        monitoring_data = config_dict.get("monitoring", {})
        
        return GitHubIntegrationConfig(
            authentication=GitHubAuthentication(**auth_data),
            repository=GitHubRepository(**repo_data),
            epic_mapping=EpicMapping(**epic_data),
            story_mapping=StoryMapping(**story_data),
            wiki_integration=WikiIntegration(**wiki_data),
            synchronization=SynchronizationConfig(**sync_data),
            quality_gates=QualityGates(**quality_data),
            monitoring=Monitoring(**monitoring_data),
            version=config_dict.get("version", "1.0.0"),
            enabled=config_dict.get("enabled", True),
            last_sync=config_dict.get("last_sync"),
            sync_statistics=config_dict.get("sync_statistics", {})
        )
    
    def get_environment_config(self) -> Dict[str, str]:
        """Get configuration from environment variables"""
        return {
            "GITHUB_TOKEN": os.getenv("GITHUB_TOKEN", ""),
            "GITHUB_OWNER": os.getenv("GITHUB_OWNER", ""),
            "GITHUB_REPO": os.getenv("GITHUB_REPO", ""),
            "GITHUB_WEBHOOK_SECRET": os.getenv("GITHUB_WEBHOOK_SECRET", ""),
            "GITHUB_CONFIG_PATH": os.getenv("GITHUB_CONFIG_PATH", "config/github_integration.json")
        }
    
    def test_configuration(self) -> Dict[str, Any]:
        """
        Test configuration validity
        
        Returns:
            Test results dictionary
        """
        results = {
            "valid": False,
            "errors": [],
            "warnings": [],
            "authentication": False,
            "repository_access": False,
            "webhook_configured": False
        }
        
        try:
            # Validate configuration
            errors = self.validate_config()
            results["errors"] = errors
            
            if not errors:
                results["valid"] = True
                
                # Test authentication would go here
                # (requires actual GitHub API client)
                results["authentication"] = bool(self.config.authentication.token)
                
                # Check webhook configuration
                results["webhook_configured"] = bool(
                    self.config.synchronization.real_time_webhook and 
                    self.config.authentication.webhook_secret
                )
            
        except Exception as e:
            results["errors"].append(f"Configuration test failed: {str(e)}")
        
        return results


# Global configuration manager instance
_config_manager = None

def get_github_config() -> GitHubIntegrationConfig:
    """Get global GitHub configuration"""
    global _config_manager
    if _config_manager is None:
        _config_manager = GitHubConfigManager()
    return _config_manager.get_config()

def reload_github_config() -> GitHubIntegrationConfig:
    """Reload GitHub configuration from file"""
    global _config_manager
    _config_manager = GitHubConfigManager()
    return _config_manager.get_config()