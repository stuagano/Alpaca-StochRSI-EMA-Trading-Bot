<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Strategy Dashboard v2.0</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
        .dashboard-card { 
            background: rgba(255,255,255,0.95); 
            border-radius: 15px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.18);
            backdrop-filter: blur(8px);
        }
        .metric-value { font-size: 1.8rem; font-weight: bold; }
        .signal-buy { background: linear-gradient(45deg, #28a745, #20c997); color: white; }
        .signal-oversold { background: linear-gradient(45deg, #ffc107, #fd7e14); color: white; }
        .signal-normal { background: linear-gradient(45deg, #6c757d, #495057); color: white; }
        .position-positive { border-left: 4px solid #28a745; background: rgba(40,167,69,0.1); }
        .position-negative { border-left: 4px solid #dc3545; background: rgba(220,53,69,0.1); }
        .streaming-active { 
            width: 12px; height: 12px; border-radius: 50%; 
            background: #28a745; animation: pulse 2s infinite; 
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .indicator-gauge { 
            width: 100%; height: 20px; background: #e9ecef; 
            border-radius: 10px; position: relative; overflow: hidden;
        }
        .gauge-fill { 
            height: 100%; border-radius: 10px; 
            transition: all 0.5s ease;
        }
        .threshold-marker {
            position: absolute; top: 0; height: 100%; width: 2px;
            background: #dc3545; left: 35%;
        }
        .chart-container {
            height: 350px;
            position: relative;
        }
    </style>
</head>
<body>
    <div class="container-fluid p-4">
        <!-- Header -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="dashboard-card p-4">
                    <div class="d-flex justify-content-between align-items-center">
                        <h2 class="mb-0"><i class="bi bi-graph-up-arrow text-primary"></i> Trading Strategy Dashboard v2.0</h2>
                        <div class="d-flex align-items-center">
                            <span id="botStatus" class="badge bg-secondary me-3">BOT STOPPED</span>
                            <button class="btn btn-success ms-3" id="startBotBtn">Start Bot</button>
                            <button class="btn btn-danger ms-2" id="stopBotBtn" disabled>Stop Bot</button>
                            <span class="streaming-active me-2 ms-3" id="streamingDot"></span>
                            <span id="streamingStatus">Connecting...</span>
                            <button class="btn btn-primary ms-3" id="startStreamBtn">
                                <i class="bi bi-play-fill"></i> Start Stream
                            </button>
                            <button class="btn btn-secondary ms-2" id="stopStreamBtn" disabled>
                                <i class="bi bi-stop-fill"></i> Stop
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Account Metrics -->
        <div class="row mb-4">
            <div class="col-md-3">
                <div class="dashboard-card p-3 text-center">
                    <h6 class="text-muted">Portfolio Value</h6>
                    <div class="metric-value text-primary" id="portfolioValue">$0</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="dashboard-card p-3 text-center">
                    <h6 class="text-muted">Cash Balance</h6>
                    <div class="metric-value text-success" id="cashBalance">$0</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="dashboard-card p-3 text-center">
                    <h6 class="text-muted">Total P/L</h6>
                    <div class="metric-value" id="totalPL">$0</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="dashboard-card p-3 text-center">
                    <h6 class="text-muted">Active Positions</h6>
                    <div class="metric-value text-info" id="positionCount">0</div>
                </div>
            </div>
        </div>

        <!-- Live Charts -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="dashboard-card p-4">
                    <h5 class="mb-3"><i class="bi bi-bar-chart-line"></i> Live Candlestick Charts</h5>
                    <div id="chartsContainer" class="row">
                        <div class="col-12 text-center text-muted">
                            <p>Start streaming to see live charts...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Live Trading Signals -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="dashboard-card p-4">
                    <h5 class="mb-3"><i class="bi bi-cpu"></i> Live Trading Signals</h5>
                    <div id="signalsContainer" class="row">
                        <div class="col-12 text-center text-muted">
                            <p>Start streaming to see live signals...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Live Positions -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="dashboard-card p-4">
                    <h5 class="mb-3"><i class="bi bi-briefcase"></i> Live Positions</h5>
                    <div id="positionsContainer" class="row">
                        <div class="col-12 text-center text-muted">
                            <p>Start streaming to see positions...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Live Prices -->
        <div class="row">
            <div class="col-12">
                <div class="dashboard-card p-4">
                    <h5 class="mb-3"><i class="bi bi-graph-up"></i> Live Market Prices</h5>
                    <div id="pricesContainer" class="row">
                        <div class="col-12 text-center text-muted">
                            <p>Start streaming to see prices...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Backtesting -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="dashboard-card p-4">
                    <h5 class="mb-3"><i class="bi bi-clock-history"></i> Backtesting</h5>
                    <div class="row">
                        <div class="col-md-3">
                            <label for="strategySelect" class="form-label">Strategy</label>
                            <select id="strategySelect" class="form-select">
                                <option value="StochRSI">StochRSI</option>
                                <option value="MACrossover">MA Crossover</option>
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label for="symbolInput" class="form-label">Symbol</label>
                            <input type="text" id="symbolInput" class="form-control" value="AAPL">
                        </div>
                        <div class="col-md-3">
                            <label for="startDateInput" class="form-label">Start Date</label>
                            <input type="date" id="startDateInput" class="form-control" value="2023-01-01">
                        </div>
                        <div class="col-md-3">
                            <label for="endDateInput" class="form-label">End Date</label>
                            <input type="date" id="endDateInput" class="form-control" value="2023-12-31">
                        </div>
                    </div>
                    <button id="runBacktestBtn" class="btn btn-success mt-3">Run Backtest</button>
                    <div id="backtestResults" class="mt-4"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        /**
         * STREAMLINED CHART UPDATE SYSTEM
         * ================================
         * 
         * This system eliminates redundant update functions and conflicts by:
         * 
         * 1. CLEAN SEPARATION OF CONCERNS:
         *    - updatePrices(): Updates price display UI only
         *    - updatePriceData(): Updates chart candlestick and whitespace series only  
         *    - updateIndicatorData(): Updates chart indicators only
         *    - batchUpdateIndicators(): Efficiently updates multiple indicators from signal data
         * 
         * 2. WHITESPACE SERIES SYNCHRONIZATION:
         *    - Invisible whitespace series maintains consistent time scale across all charts
         *    - All indicators sync to the same timeline as price data
         *    - Prevents timestamp conflicts and "Cannot update oldest data" errors
         * 
         * 3. NO CIRCULAR UPDATES:
         *    - Removed redundant updateChart() calls that caused conflicts
         *    - Each update function has a single, specific responsibility
         *    - Price and indicator updates are independent and non-conflicting
         * 
         * 4. ROBUST ERROR HANDLING:
         *    - Enhanced timestamp validation prevents [object Object] errors
         *    - Graceful fallbacks for invalid data
         *    - Comprehensive logging for debugging
         */
        
        let socket;
        let isStreaming = false;
        let charts = {}; // To store chart instances
        let lastBarTimes = {}; // To store last bar timestamp for each ticker for synchronization

        /**
         * Robust timestamp validation and conversion utility
         * Fixes the "Cannot update oldest data, last time=[object Object]" error
         * Ensures all timestamps are valid UNIX timestamps (integers)
         */
        function validateTimestamp(timestamp, fallbackContext = '') {
            try {
                let validTime;
                
                // Handle different timestamp formats
                if (timestamp === null || timestamp === undefined) {
                    console.warn(`Null/undefined timestamp ${fallbackContext}, using current time`);
                    validTime = Math.floor(Date.now() / 1000);
                } else if (typeof timestamp === 'object') {
                    // If timestamp is a Date object or similar, convert it
                    if (timestamp instanceof Date) {
                        validTime = Math.floor(timestamp.getTime() / 1000);
                    } else {
                        // Try to convert object to number
                        validTime = Math.floor(new Date(timestamp).getTime() / 1000);
                    }
                } else if (typeof timestamp === 'string') {
                    // Handle string timestamps (could be ISO string or numeric string)
                    if (timestamp.includes('-') || timestamp.includes('T')) {
                        // ISO string format
                        validTime = Math.floor(new Date(timestamp).getTime() / 1000);
                    } else {
                        // Numeric string
                        validTime = Math.floor(parseFloat(timestamp));
                    }
                } else {
                    // Already a number, just ensure it's an integer
                    validTime = Math.floor(Number(timestamp));
                }
                
                // Validate the result
                if (isNaN(validTime) || validTime <= 0 || validTime > Date.now() / 1000 + 86400) {
                    console.error(`Invalid timestamp ${fallbackContext}:`, timestamp, 'converted to:', validTime);
                    validTime = Math.floor(Date.now() / 1000); // Fallback to current time
                }
                
                return validTime;
            } catch (error) {
                console.error(`Error validating timestamp ${fallbackContext}:`, error, 'original value:', timestamp);
                return Math.floor(Date.now() / 1000); // Safe fallback
            }
        }

        // Initialize socket connection
        function initSocket() {
            socket = io();
            
            socket.on('connect', function() {
                console.log('Connected to server');
                document.getElementById('streamingStatus').textContent = 'Connected';
            });
            
            socket.on('disconnect', function() {
                console.log('Disconnected from server');
                document.getElementById('streamingStatus').textContent = 'Disconnected';
            });
            
            socket.on('real_time_update', function(data) {
                console.log('üî• REAL-TIME UPDATE RECEIVED:', data);
                try {
                    handleRealTimeUpdate(data);
                    console.log('‚úÖ Real-time update processed successfully');
                } catch (error) {
                    console.error('‚ùå Real-time update failed:', error);
                }
            });
            
            socket.on('streaming_status', function(data) {
                isStreaming = data.active;
                if (isStreaming) {
                    initializeCharts(Object.keys(charts).length > 0 ? Object.keys(charts) : []);
                }
                updateStreamingControls();
            });
        }

        // Update entire dashboard with clean separation of concerns
        function updateDashboard(data) {
            console.log('üîÑ Updating dashboard with data:', data);
            
            // Update account metrics
            if (data.account_info) {
                updateAccountMetrics(data.account_info);
            }
            
            // Update positions display
            if (data.positions !== undefined) {
                updatePositions(data.positions);
            }
            
            // Update trading signals and initialize charts if needed
            if (data.ticker_signals) {
                updateTradingSignals(data.ticker_signals);
                // Initialize charts if we get signals and charts are not yet created
                if (Object.keys(charts).length === 0) {
                    console.log('üìä Initializing charts for first time');
                    initializeCharts(Object.keys(data.ticker_signals));
                } else {
                    // Update indicators only for existing charts
                    console.log('üìà Updating indicators for existing charts');
                    batchUpdateIndicators(data.ticker_signals);
                }
            }
            
            // Update price display (price data for charts is updated separately via updatePriceData)
            if (data.ticker_prices) {
                updatePrices(data.ticker_prices);
            }
            
            console.log('‚úÖ Dashboard update completed');
        }
        
        // Initialize charts with indicators
        async function initializeCharts(tickers) {
            try {
                console.log('Initializing charts for:', tickers);
                const container = document.getElementById('chartsContainer');
                if (tickers.length === 0 && Object.keys(charts).length === 0) {
                    container.innerHTML = '<div class="col-12 text-center text-muted"><p>No tickers configured for charts.</p></div>';
                    return;
                }

                container.innerHTML = ''; // Clear previous content

                for (const ticker of tickers) {
                    if (charts[ticker]) {
                        console.log(`Chart for ${ticker} already exists. Skipping.`);
                        continue; 
                    }

                    if (typeof LightweightCharts === 'undefined') {
                        console.error("LightweightCharts library is not loaded!");
                        return;
                    }
                    
                    console.log(`Creating chart for ${ticker}`);
                    const chartWrapper = document.createElement('div');
                    chartWrapper.className = 'col-lg-6 mb-4';
                    chartWrapper.innerHTML = `
                        <div class="card">
                            <div class="card-header">
                                <h5 class="mb-0">${ticker} - Candlestick Chart with Indicators</h5>
                            </div>
                            <div class="card-body p-2">
                                <div class="chart-container" id="main-chart-${ticker}" style="height: 300px;"></div>
                                <div class="chart-container" id="rsi-chart-${ticker}" style="height: 150px; margin-top: 10px;"></div>
                                <div class="chart-container" id="stochrsi-chart-${ticker}" style="height: 150px; margin-top: 10px;"></div>
                            </div>
                        </div>
                    `;
                    container.appendChild(chartWrapper);

                    // Create main candlestick chart
                    const mainChart = LightweightCharts.createChart(document.getElementById(`main-chart-${ticker}`), {
                        width: chartWrapper.querySelector('.card-body').clientWidth,
                        height: 300,
                        layout: {
                            backgroundColor: '#ffffff',
                            textColor: 'rgba(33, 56, 77, 1)',
                        },
                        grid: {
                            vertLines: { color: 'rgba(197, 203, 206, 0.5)' },
                            horzLines: { color: 'rgba(197, 203, 206, 0.5)' },
                        },
                        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                        timeScale: { timeVisible: true, secondsVisible: false },
                        rightPriceScale: {
                            borderColor: 'rgba(197, 203, 206, 1)',
                        },
                    });

                    // Create RSI chart
                    const rsiChart = LightweightCharts.createChart(document.getElementById(`rsi-chart-${ticker}`), {
                        width: chartWrapper.querySelector('.card-body').clientWidth,
                        height: 150,
                        layout: {
                            backgroundColor: '#ffffff',
                            textColor: 'rgba(33, 56, 77, 1)',
                        },
                        grid: {
                            vertLines: { color: 'rgba(197, 203, 206, 0.5)' },
                            horzLines: { color: 'rgba(197, 203, 206, 0.5)' },
                        },
                        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                        timeScale: { timeVisible: false, secondsVisible: false },
                        rightPriceScale: {
                            borderColor: 'rgba(197, 203, 206, 1)',
                        },
                    });

                    // Create StochRSI chart
                    const stochRsiChart = LightweightCharts.createChart(document.getElementById(`stochrsi-chart-${ticker}`), {
                        width: chartWrapper.querySelector('.card-body').clientWidth,
                        height: 150,
                        layout: {
                            backgroundColor: '#ffffff',
                            textColor: 'rgba(33, 56, 77, 1)',
                        },
                        grid: {
                            vertLines: { color: 'rgba(197, 203, 206, 0.5)' },
                            horzLines: { color: 'rgba(197, 203, 206, 0.5)' },
                        },
                        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                        timeScale: { timeVisible: true, secondsVisible: false },
                        rightPriceScale: {
                            borderColor: 'rgba(197, 203, 206, 1)',
                        },
                    });

                    // Add whitespace series for time synchronization (invisible)
                    const whitespaceSeries = mainChart.addSeries(LightweightCharts.LineSeries, {
                        color: 'rgba(0, 0, 0, 0)', // Completely transparent
                        lineWidth: 0,
                        priceLineVisible: false,
                        lastValueVisible: false,
                        crosshairMarkerVisible: false,
                        visible: false, // Make series invisible
                    });

                    // Add candlestick series
                    const candlestickSeries = mainChart.addSeries(LightweightCharts.CandlestickSeries, {
                        upColor: '#26a69a', 
                        downColor: '#ef5350', 
                        borderVisible: false,
                        wickUpColor: '#26a69a', 
                        wickDownColor: '#ef5350',
                    });

                    // Add EMA series that will be updated independently
                    const emaSeries = mainChart.addSeries(LightweightCharts.LineSeries, {
                        color: '#FF6D00',
                        lineWidth: 2,
                        title: 'EMA',
                        priceScaleId: 'right', // Use same price scale as candlesticks
                    });

                    const rsiSeries = rsiChart.addSeries(LightweightCharts.LineSeries, {
                        color: '#2196F3',
                        lineWidth: 2,
                        title: 'RSI',
                    });

                    const stochRsiKSeries = stochRsiChart.addSeries(LightweightCharts.LineSeries, {
                        color: '#4CAF50',
                        lineWidth: 2,
                        title: 'StochRSI %K',
                    });

                    const stochRsiDSeries = stochRsiChart.addSeries(LightweightCharts.LineSeries, {
                        color: '#FF5722',
                        lineWidth: 2,
                        title: 'StochRSI %D',
                    });

                    // Add threshold lines for RSI
                    rsiChart.addSeries(LightweightCharts.LineSeries, {
                        color: 'rgba(255, 0, 0, 0.5)',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    }).setData([
                        { time: 1640995200, value: 70 }, // Overbought line
                        { time: Date.now() / 1000, value: 70 }
                    ]);

                    rsiChart.addSeries(LightweightCharts.LineSeries, {
                        color: 'rgba(0, 255, 0, 0.5)',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    }).setData([
                        { time: 1640995200, value: 30 }, // Oversold line
                        { time: Date.now() / 1000, value: 30 }
                    ]);

                    // Add threshold lines for StochRSI
                    stochRsiChart.addSeries(LightweightCharts.LineSeries, {
                        color: 'rgba(255, 0, 0, 0.5)',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    }).setData([
                        { time: 1640995200, value: 80 }, // Overbought line
                        { time: Date.now() / 1000, value: 80 }
                    ]);

                    stochRsiChart.addSeries(LightweightCharts.LineSeries, {
                        color: 'rgba(0, 255, 0, 0.5)',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    }).setData([
                        { time: 1640995200, value: 20 }, // Oversold line
                        { time: Date.now() / 1000, value: 20 }
                    ]);

                    // Store chart references
                    charts[ticker] = { 
                        mainChart, 
                        rsiChart, 
                        stochRsiChart,
                        whitespaceSeries,
                        candlestickSeries,
                        emaSeries,
                        rsiSeries,
                        stochRsiKSeries,
                        stochRsiDSeries
                    };

                    console.log(`Chart for ${ticker} created.`);

                    // Synchronize crosshairs between charts
                    [mainChart, rsiChart, stochRsiChart].forEach(chart => {
                        chart.subscribeCrosshairMove(param => {
                            if (param.point === undefined || !param.time || param.point.x < 0 || param.point.x > chart.options().width || param.point.y < 0 || param.point.y > chart.options().height) {
                                [mainChart, rsiChart, stochRsiChart].forEach(c => c.clearCrosshairPosition());
                            } else {
                                [mainChart, rsiChart, stochRsiChart].forEach(c => c.setCrosshairPosition(param.point.y, param.time, c.priceScale('').id));
                            }
                        });
                    });

                    // Fetch historical data and indicators
                    try {
                        console.log(`Fetching historical data for ${ticker}...`);
                        
                        // Fetch price data
                        const priceResponse = await fetch(`/api/chart/${ticker}?limit=200`);
                        const priceData = await priceResponse.json();
                        
                        // Fetch indicator data
                        const indicatorResponse = await fetch(`/api/chart_indicators/${ticker}?limit=200`);
                        const indicatorData = await indicatorResponse.json();
                        
                        console.log(`Historical data response for ${ticker}:`, priceData);
                        console.log(`Indicator data response for ${ticker}:`, indicatorData);
                        
                        if (priceData.success && priceData.data) {
                            const formattedData = priceData.data.timestamps.map((time, index) => {
                                return {
                                    time: validateTimestamp(time, `for ${ticker} historical data`),
                                    open: Number(priceData.data.open[index]),
                                    high: Number(priceData.data.high[index]),
                                    low: Number(priceData.data.low[index]),
                                    close: Number(priceData.data.close[index]),
                                };
                            });
                            
                            // Set data on candlestick series
                            candlestickSeries.setData(formattedData);
                            
                            // Set whitespace data for time synchronization (using close prices but invisible)
                            const whitespaceData = priceData.data.timestamps.map((time, index) => {
                                return {
                                    time: validateTimestamp(time, `for ${ticker} whitespace sync`),
                                    value: Number(priceData.data.close[index]), // Use close price for proper scaling
                                };
                            });
                            whitespaceSeries.setData(whitespaceData);
                            
                            console.log(`Historical price data for ${ticker} set on chart.`);
                        }

                        if (indicatorData.success && indicatorData.indicators) {
                            // Set EMA data
                            if (indicatorData.indicators.ema) {
                                emaSeries.setData(indicatorData.indicators.ema);
                                console.log(`EMA data for ${ticker} set on chart.`);
                            }

                            // Set RSI data
                            if (indicatorData.indicators.rsi) {
                                rsiSeries.setData(indicatorData.indicators.rsi);
                                console.log(`RSI data for ${ticker} set on chart.`);
                            }

                            // Set StochRSI data
                            if (indicatorData.indicators.stochRSI_K) {
                                stochRsiKSeries.setData(indicatorData.indicators.stochRSI_K);
                                console.log(`StochRSI K data for ${ticker} set on chart.`);
                            }
                            
                            if (indicatorData.indicators.stochRSI_D) {
                                stochRsiDSeries.setData(indicatorData.indicators.stochRSI_D);
                                console.log(`StochRSI D data for ${ticker} set on chart.`);
                            }
                        }
                        
                    } catch (error) {
                        console.error(`Error fetching chart data for ${ticker}:`, error);
                    }
                }

                // Handle window resize
                window.addEventListener('resize', () => {
                    Object.values(charts).forEach(chartSet => {
                        if (chartSet.mainChart) chartSet.mainChart.applyOptions({ width: chartSet.mainChart.options().width });
                        if (chartSet.rsiChart) chartSet.rsiChart.applyOptions({ width: chartSet.rsiChart.options().width });
                        if (chartSet.stochRsiChart) chartSet.stochRsiChart.applyOptions({ width: chartSet.stochRsiChart.options().width });
                    });
                });

            } catch (error) {
                console.error('Error in initializeCharts:', error);
            }
        }
        
        /**
         * CHART UPDATE ARCHITECTURE:
         * 
         * The streamlined chart update system uses whitespace series for time synchronization:
         * 1. Time synchronization: Invisible whitespace series maintains consistent time scale
         * 2. Independent updates: Price and indicators are updated separately to prevent conflicts
         * 3. Performance: Reduces chart re-rendering and eliminates circular update calls
         * 4. Flexibility: Allows different update frequencies for price vs indicator data
         * 
         * Key functions:
         * - updatePriceData(ticker): Updates candlestick and whitespace series only
         * - updateIndicatorData(ticker): Updates indicators only, synchronized to whitespace series
         * - batchUpdateIndicators(data): Efficiently updates multiple indicators from signal data
         */
        
        // Update price data and maintain time synchronization via whitespace series
        function updatePriceData(ticker) {
            fetch(`/api/latest_bar/${ticker}`)
                .then(response => response.json())
                .then(data => {
                    console.log(`üìä Latest bar data for ${ticker}:`, data);
                    if (data.success && charts[ticker] && data.bar) {
                        try {
                            // Use centralized timestamp validation to fix [object Object] error
                            const barTime = validateTimestamp(data.bar.time, `for ${ticker} price update`);
                            console.log(`‚è∞ Processed timestamp for ${ticker}: ${barTime} (${new Date(barTime * 1000).toISOString()})`);
                            
                            const barData = {
                                time: barTime,
                                open: Number(data.bar.open),
                                high: Number(data.bar.high),
                                low: Number(data.bar.low),
                                close: Number(data.bar.close)
                            };
                            
                            // Determine if this is a new candle or an update to existing candle
                            const isNewCandle = data.is_new_candle || false;
                            const isCurrentMinute = data.is_current_minute || false;
                            const barAgeSeconds = data.bar_age_seconds || 0;
                            
                            console.log(`üïê Candle analysis for ${ticker}:`, {
                                isNewCandle,
                                isCurrentMinute, 
                                barAgeSeconds: Math.round(barAgeSeconds),
                                time: new Date(barTime * 1000).toLocaleTimeString()
                            });
                            
                            // Update the candlestick chart with the bar data
                            // LightweightCharts automatically handles new vs update based on timestamp
                            charts[ticker].candlestickSeries.update(barData);
                            
                            // Update whitespace series for time synchronization
                            charts[ticker].whitespaceSeries.update({
                                time: barTime,
                                value: Number(data.bar.close) // Use close price but series remains invisible
                            });
                            
                            // Store the last bar time for indicator synchronization
                            lastBarTimes[ticker] = barTime;
                            
                            // Enhanced logging based on candle type
                            if (isNewCandle) {
                                console.log(`üÜï NEW CANDLE for ${ticker}:`, {
                                    time: new Date(barTime * 1000).toLocaleTimeString(),
                                    open: data.bar.open,
                                    high: data.bar.high,
                                    low: data.bar.low,
                                    close: data.bar.close,
                                    age: `${Math.round(barAgeSeconds)}s old`
                                });
                            } else {
                                console.log(`üîÑ UPDATING candle for ${ticker}:`, {
                                    time: new Date(barTime * 1000).toLocaleTimeString(),
                                    close: data.bar.close,
                                    high: data.bar.high,
                                    low: data.bar.low,
                                    age: `${Math.round(barAgeSeconds)}s old`
                                });
                            }
                            
                            // If we have previous bar info, log the change
                            if (data.prev_bar) {
                                const priceChange = data.bar.close - data.prev_bar.close;
                                const percentChange = (priceChange / data.prev_bar.close * 100).toFixed(2);
                                console.log(`üíπ ${ticker} price change from previous bar: ${priceChange > 0 ? '+' : ''}${priceChange.toFixed(4)} (${percentChange}%)`);
                            }
                            
                            // Visual indicator for new candles in console
                            if (isNewCandle) {
                                console.log(`üéØ ${ticker}: Real-time candle formation detected! New minute started.`);
                            }
                            
                        } catch (error) {
                            console.error(`‚ùå Error updating price data for ${ticker}:`, error);
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è No valid bar data received for ${ticker}:`, data);
                    }
                })
                .catch(error => {
                    console.error(`üîå Network error fetching price data for ${ticker}:`, error);
                });
        }
        
        // Update indicator data independently from price data
        function updateIndicatorData(ticker) {
            fetch(`/api/indicators/${ticker}`)
                .then(response => response.json())
                .then(data => {
                    console.log(`Latest indicator data for ${ticker}:`, data);
                    if (data.success && data.indicators && charts[ticker]) {
                        try {
                            // Use the last bar time for proper synchronization with price data
                            // If no bar time is available, fall back to current time
                            const syncTime = validateTimestamp(lastBarTimes[ticker] || Math.floor(Date.now() / 1000), `for ${ticker} indicators sync`);
                            console.log(`Using sync time for ${ticker} indicators: ${syncTime} (${new Date(syncTime * 1000).toISOString()})`);
                            
                            // Update EMA independently
                            if (data.indicators.EMA && charts[ticker].emaSeries) {
                                charts[ticker].emaSeries.update({
                                    time: syncTime,
                                    value: Number(data.indicators.EMA)
                                });
                                console.log(`üìà EMA for ${ticker} updated: ${Number(data.indicators.EMA).toFixed(4)}`);
                            }

                            // Update RSI independently
                            if (data.indicators.RSI && charts[ticker].rsiSeries) {
                                charts[ticker].rsiSeries.update({
                                    time: syncTime,
                                    value: Number(data.indicators.RSI)
                                });
                                console.log(`üìä RSI for ${ticker} updated: ${Number(data.indicators.RSI).toFixed(2)}`);
                            }

                            // Update StochRSI independently
                            if (data.indicators.StochRSI_K && charts[ticker].stochRsiKSeries) {
                                charts[ticker].stochRsiKSeries.update({
                                    time: syncTime,
                                    value: Number(data.indicators.StochRSI_K)
                                });
                                console.log(`üìà StochRSI K for ${ticker} updated: ${Number(data.indicators.StochRSI_K).toFixed(2)}`);
                            }

                            if (data.indicators.StochRSI_D && charts[ticker].stochRsiDSeries) {
                                charts[ticker].stochRsiDSeries.update({
                                    time: syncTime,
                                    value: Number(data.indicators.StochRSI_D)
                                });
                                console.log(`üìà StochRSI D for ${ticker} updated: ${Number(data.indicators.StochRSI_D).toFixed(2)}`);
                            }

                            console.log(`‚úÖ Indicators for ${ticker} updated successfully`);
                        } catch (error) {
                            console.error(`‚ùå Error updating indicators for ${ticker}:`, error);
                        }
                    }
                })
                .catch(error => {
                    console.error(`Network error updating indicators for ${ticker}:`, error);
                });
        }
        
        /**
         * Batch update indicators from signal data for better performance
         * This function extracts indicator values from the signal data structure
         */
        function batchUpdateIndicators(tickerSignalData) {
            Object.entries(tickerSignalData).forEach(([ticker, signalData]) => {
                if (charts[ticker] && signalData) {
                    const syncTime = validateTimestamp(lastBarTimes[ticker] || Math.floor(Date.now() / 1000), `for ${ticker} batch indicators`);
                    
                    try {
                        // Extract StochRSI values from signal data
                        if (signalData.stochRSI) {
                            const stochRSI = signalData.stochRSI;
                            
                            if (stochRSI.k !== undefined && charts[ticker].stochRsiKSeries) {
                                charts[ticker].stochRsiKSeries.update({
                                    time: syncTime,
                                    value: Number(stochRSI.k)
                                });
                                console.log(`üìà Updated StochRSI K for ${ticker}: ${Number(stochRSI.k).toFixed(2)}`);
                            }

                            if (stochRSI.d !== undefined && charts[ticker].stochRsiDSeries) {
                                charts[ticker].stochRsiDSeries.update({
                                    time: syncTime,
                                    value: Number(stochRSI.d)
                                });
                                console.log(`üìà Updated StochRSI D for ${ticker}: ${Number(stochRSI.d).toFixed(2)}`);
                            }
                        }
                        
                        // Note: Other indicators (RSI, EMA) are updated separately via updateIndicatorData() when needed
                        
                        console.log(`üìä Batch updated indicators for ${ticker}`);
                    } catch (error) {
                        console.error(`‚ùå Error in batch update for ${ticker}:`, error);
                    }
                }
            });
        }
        
        /**
         * Update only specific indicators without affecting others
         * Useful for selective updates based on signal changes
         */
        function updateSpecificIndicator(ticker, indicatorType, indicatorValue) {
            if (!charts[ticker]) return;
            
            const syncTime = validateTimestamp(lastBarTimes[ticker] || Math.floor(Date.now() / 1000), `for ${ticker} specific indicator ${indicatorType}`);
            
            try {
                switch(indicatorType) {
                    case 'EMA':
                        if (charts[ticker].emaSeries) {
                            charts[ticker].emaSeries.update({
                                time: syncTime,
                                value: Number(indicatorValue)
                            });
                        }
                        break;
                    case 'RSI':
                        if (charts[ticker].rsiSeries) {
                            charts[ticker].rsiSeries.update({
                                time: syncTime,
                                value: Number(indicatorValue)
                            });
                        }
                        break;
                    case 'StochRSI_K':
                        if (charts[ticker].stochRsiKSeries) {
                            charts[ticker].stochRsiKSeries.update({
                                time: syncTime,
                                value: Number(indicatorValue)
                            });
                        }
                        break;
                    case 'StochRSI_D':
                        if (charts[ticker].stochRsiDSeries) {
                            charts[ticker].stochRsiDSeries.update({
                                time: syncTime,
                                value: Number(indicatorValue)
                            });
                        }
                        break;
                    default:
                        console.warn(`Unknown indicator type: ${indicatorType}`);
                }
                console.log(`üìà Updated ${indicatorType} for ${ticker}: ${Number(indicatorValue)}`);
            } catch (error) {
                console.error(`‚ùå Error updating ${indicatorType} for ${ticker}:`, error);
            }
        }

        // Update account metrics
        function updateAccountMetrics(account) {
            console.log('üí∞ Updating account metrics:', account);
            if (!account) {
                console.warn('‚ö†Ô∏è No account data provided');
                return;
            }
            try {
                document.getElementById('portfolioValue').textContent = `$${(account.portfolio_value || 0).toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                document.getElementById('cashBalance').textContent = `$${(account.cash || 0).toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                console.log('‚úÖ Account metrics updated successfully');
            } catch (error) {
                console.error('‚ùå Error updating account metrics:', error);
            }
        }

        // Update positions
        function updatePositions(positions) {
            console.log('üìä Updating positions:', positions);
            const container = document.getElementById('positionsContainer');
            if (!positions || positions.length === 0) {
                console.log('‚ö†Ô∏è No positions to display');
                container.innerHTML = '<div class="col-12 text-center text-muted"><p>No positions available</p></div>';
                document.getElementById('positionCount').textContent = '0';
                document.getElementById('totalPL').textContent = '$0.00';
                return;
            }

            let totalPL = positions.reduce((sum, pos) => sum + pos.unrealized_pl, 0);
            document.getElementById('positionCount').textContent = positions.length;
            document.getElementById('totalPL').textContent = `${totalPL >= 0 ? '+' : ''}$${Math.abs(totalPL).toLocaleString('en-US', {minimumFractionDigits: 2})}`;
            document.getElementById('totalPL').className = `metric-value ${totalPL >= 0 ? 'text-success' : 'text-danger'}`;

            let html = '';
            positions.forEach((pos, index) => {
                try {
                    console.log(`Processing position ${index}:`, pos);
                    const isPositive = pos.unrealized_pl >= 0;
                    const plValue = typeof pos.unrealized_pl === 'number' ? pos.unrealized_pl : 0;
                    const plPercentage = typeof pos.unrealized_plpc === 'number' ? pos.unrealized_plpc : 0;
                    const marketValue = typeof pos.market_value === 'number' ? pos.market_value : 0;
                    
                    html += `
                        <div class="col-md-4 mb-3">
                            <div class="card ${isPositive ? 'position-positive' : 'position-negative'}">
                                <div class="card-body">
                                    <h5 class="card-title">${pos.symbol || 'Unknown'}</h5>
                                    <p class="mb-2"><strong>Qty:</strong> ${pos.qty || 0} | <strong>Value:</strong> $${marketValue.toLocaleString()}</p>
                                    <div class="${isPositive ? 'text-success' : 'text-danger'}">
                                        <strong>P/L:</strong> ${isPositive ? '+' : ''}$${Math.abs(plValue).toFixed(2)} (${plPercentage.toFixed(2)}%)
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } catch (error) {
                    console.error(`Error processing position ${index}:`, error, pos);
                }
            });
            container.innerHTML = html;
            console.log('‚úÖ Positions rendered successfully');
        }

        // Update trading signals
        function updateTradingSignals(signals) {
            const container = document.getElementById('signalsContainer');
            if (!signals || Object.keys(signals).length === 0) {
                container.innerHTML = '<div class="col-12 text-center text-muted"><p>No signals available</p></div>';
                return;
            }
            
            let html = '';
            Object.entries(signals).forEach(([ticker, data]) => {
                if (data && data.stochRSI) {
                    const signal = data.stochRSI;
                    let signalClass = signal.signal === 1 ? 'signal-buy' : (signal.status === 'OVERSOLD' ? 'signal-oversold' : 'signal-normal');
                    let signalText = signal.signal === 1 ? 'BUY' : signal.status;
                    html += `
                        <div class="col-md-4 mb-3">
                            <div class="card ${signalClass} text-white">
                                <div class="card-body text-center">
                                    <h5>${ticker}</h5>
                                    <div class="display-4">${signalText}</div>
                                    <small>K: ${signal.k.toFixed(1)} | D: ${signal.d.toFixed(1)} | Thresh: ${signal.lower_band}</small>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });
            container.innerHTML = html;
        }

        // Global tracking for new candle detection
        let lastCandleTimestamps = {};
        
        // Update prices display only (charts updated separately for better performance)
        function updatePrices(prices) {
            const container = document.getElementById('pricesContainer');
            if (!prices || Object.keys(prices).length === 0) {
                container.innerHTML = '<div class="col-12 text-center text-muted"><p>No prices available</p></div>';
                return;
            }

            let html = '';
            Object.entries(prices).forEach(([ticker, price]) => {
                html += `
                    <div class="col-md-4 mb-3">
                        <div class="dashboard-card p-3 text-center">
                            <h6 class="text-muted">${ticker}</h6>
                            <div class="metric-value text-primary">$${(price || 0).toFixed(4)}</div>
                        </div>
                    </div>
                `;
                // Update price data for this ticker with candle tracking
                updatePriceDataWithTracking(ticker);
            });
            container.innerHTML = html;
        }
        
        // Enhanced price update function with new candle tracking
        function updatePriceDataWithTracking(ticker) {
            updatePriceData(ticker);
            
            // Additionally check if we need to refresh the entire chart when new candles form
            fetch(`/api/latest_bar/${ticker}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.bar && data.is_new_candle) {
                        const currentTimestamp = data.bar.time;
                        const lastKnownTimestamp = lastCandleTimestamps[ticker];
                        
                        // If this is genuinely a new candle we haven't seen before
                        if (!lastKnownTimestamp || currentTimestamp > lastKnownTimestamp) {
                            console.log(`üöÄ DETECTED NEW CANDLE for ${ticker}! Refreshing chart data...`);
                            lastCandleTimestamps[ticker] = currentTimestamp;
                            
                            // Refresh chart with recent data to ensure we have the new candle
                            refreshChartData(ticker);
                        }
                    }
                })
                .catch(error => {
                    console.error(`Error checking for new candles for ${ticker}:`, error);
                });
        }
        
        // Function to refresh chart data when new candles are detected
        function refreshChartData(ticker) {
            if (!charts[ticker]) return;
            
            fetch(`/api/realtime_bars/${ticker}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.bars && data.bars.length > 0) {
                        console.log(`üìä Refreshing chart data for ${ticker} with ${data.bars.length} bars`);
                        
                        // Get the last 20 bars to update the chart smoothly
                        const recentBars = data.bars.slice(-20);
                        
                        // Update candlestick series with recent data
                        charts[ticker].candlestickSeries.setData(recentBars);
                        
                        // Update whitespace series for synchronization
                        const whitespaceData = recentBars.map(bar => ({
                            time: bar.time,
                            value: bar.close
                        }));
                        charts[ticker].whitespaceSeries.setData(whitespaceData);
                        
                        // Update the last bar time for synchronization
                        if (recentBars.length > 0) {
                            lastBarTimes[ticker] = recentBars[recentBars.length - 1].time;
                        }
                        
                        console.log(`‚úÖ Chart data refreshed for ${ticker}`);
                        
                        // Also refresh indicators after new candle data is loaded
                        setTimeout(() => {
                            updateIndicatorData(ticker);
                        }, 500); // Small delay to ensure price data is processed first
                    }
                })
                .catch(error => {
                    console.error(`Error refreshing chart data for ${ticker}:`, error);
                });
        }
        
        // Enhanced real-time update mechanism with better candle handling
        function handleRealTimeUpdate(data) {
            console.log('üîÑ Processing real-time update:', data);
            
            // Update dashboard components
            updateDashboard(data);
            
            // Use WebSocket candlestick data directly instead of making API calls
            if (data.ticker_candlesticks) {
                Object.keys(data.ticker_candlesticks).forEach(ticker => {
                    const candlestickData = data.ticker_candlesticks[ticker];
                    if (candlestickData && candlestickData.data && charts[ticker]) {
                        try {
                            console.log(`üìä Updating ${ticker} with WebSocket candlestick data:`, candlestickData.data.length, 'bars');
                            
                            // Update candlestick series with recent data from WebSocket
                            charts[ticker].candlestickSeries.setData(candlestickData.data);
                            
                            // Update whitespace series with the latest bar for sync
                            const latestBar = candlestickData.data[candlestickData.data.length - 1];
                            if (latestBar) {
                                charts[ticker].whitespaceSeries.update({
                                    time: latestBar.time,
                                    value: latestBar.close
                                });
                                
                                // Store last bar time for indicator synchronization
                                lastBarTimes[ticker] = latestBar.time;
                            }
                            
                        } catch (error) {
                            console.error(`‚ùå Error updating ${ticker} candlestick data:`, error);
                        }
                    }
                });
            }
            
            // Fallback: For tickers without candlestick data, use API calls (this should be rare now)
            if (data.ticker_prices && !data.ticker_candlesticks) {
                Object.keys(data.ticker_prices).forEach(ticker => {
                    setTimeout(() => {
                        updatePriceDataWithTracking(ticker);
                    }, Math.random() * 1000);
                });
            }
        }

        // Update streaming controls
        function updateStreamingControls() {
            const startBtn = document.getElementById('startStreamBtn');
            const stopBtn = document.getElementById('stopStreamBtn');
            const status = document.getElementById('streamingStatus');

            startBtn.disabled = isStreaming;
            stopBtn.disabled = !isStreaming;
            status.textContent = isStreaming ? 'Streaming Live' : 'Connected';
            status.className = isStreaming ? 'text-success fw-bold' : 'text-muted';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initSocket();
            
            document.getElementById('startStreamBtn').addEventListener('click', function() {
                socket.emit('start_streaming', {interval: 5});
            });
            
            document.getElementById('stopStreamBtn').addEventListener('click', function() {
                socket.emit('stop_streaming');
            });

            document.getElementById('startBotBtn').addEventListener('click', function() {
                fetch('/api/bot/start', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        updateBotStatus(data.running);
                    });
            });

            document.getElementById('stopBotBtn').addEventListener('click', function() {
                fetch('/api/bot/stop', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        updateBotStatus(data.running);
                    });
            });

            function updateBotStatus(running) {
                const statusEl = document.getElementById('botStatus');
                const startBtn = document.getElementById('startBotBtn');
                const stopBtn = document.getElementById('stopBotBtn');

                if (running) {
                    statusEl.textContent = 'BOT RUNNING';
                    statusEl.className = 'badge bg-success me-3';
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                } else {
                    statusEl.textContent = 'BOT STOPPED';
                    statusEl.className = 'badge bg-secondary me-3';
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                }
            }

            document.getElementById('runBacktestBtn').addEventListener('click', function() {
                const strategy = document.getElementById('strategySelect').value;
                const symbol = document.getElementById('symbolInput').value;
                const startDate = document.getElementById('startDateInput').value;
                const endDate = document.getElementById('endDateInput').value;

                fetch('/api/backtest', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        strategy: strategy,
                        symbol: symbol,
                        start_date: startDate,
                        end_date: endDate
                    })
                })
                .then(response => response.json())
                .then(data => {
                    const resultsContainer = document.getElementById('backtestResults');
                    if (data.success) {
                        const results = data.results;
                        resultsContainer.innerHTML = `
                            <h5>Backtest Results</h5>
                            <p>Sharpe Ratio: ${results.performance.sharpe_ratio.toFixed(2)}</p>
                            <p>Total Returns: ${(results.performance.total_returns * 100).toFixed(2)}%</p>
                            <div id="backtestChart" style="height: 400px;"></div>
                        `;

                        const chart = LightweightCharts.createChart(document.getElementById('backtestChart'), {
                            width: resultsContainer.clientWidth,
                            height: 400,
                        });
                        const lineSeries = chart.addLineSeries();
                        lineSeries.setData(results.portfolio_value.map((value, index) => ({
                            time: new Date(startDate).getTime() / 1000 + index * 86400,
                            value: value
                        })));
                    } else {
                        resultsContainer.innerHTML = `<p class="text-danger">Error: ${data.error}</p>`;
                    }
                });
            });
        });
    </script>
</body>
</html>