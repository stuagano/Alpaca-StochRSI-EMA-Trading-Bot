/**
 * Enhanced Signal Integration with Multi-Timeframe Validation
 * ==========================================================
 * 
 * Extends the existing signal integration with multi-timeframe validation capabilities
 * Integrates with the MultiTimeframeValidator for comprehensive signal validation
 */

class EnhancedSignalIntegration extends SignalIntegration {
    constructor(options = {}) {\n        super(options);\n        \n        // Enhanced configuration\n        this.config = {\n            ...this.config,\n            enableMultiTimeframeValidation: true,\n            timeframeValidationTimeout: 5000,\n            requireTimeframeConsensus: true,\n            consensusThreshold: 0.75,\n            showAlignmentWidget: true,\n            adaptiveSignalStrength: true,\n            ...options\n        };\n        \n        // Multi-timeframe components\n        this.multiTimeframeValidator = null;\n        this.alignmentWidget = null;\n        \n        // Enhanced state\n        this.validatedSignals = new Map();\n        this.rejectedSignals = new Map();\n        this.alignmentStatus = new Map();\n        \n        // Performance tracking\n        this.enhancedMetrics = {\n            totalSignalsReceived: 0,\n            signalsValidated: 0,\n            signalsRejected: 0,\n            consensusAchieved: 0,\n            validationTime: [],\n            performanceImprovement: 0\n        };\n        \n        this.initializeEnhancements();\n    }\n    \n    /**\n     * Initialize enhanced features\n     */\n    async initializeEnhancements() {\n        try {\n            // Initialize multi-timeframe validator\n            if (this.config.enableMultiTimeframeValidation) {\n                await this.initializeMultiTimeframeValidator();\n            }\n            \n            // Initialize alignment widget if enabled\n            if (this.config.showAlignmentWidget) {\n                this.initializeAlignmentWidget();\n            }\n            \n            // Set up enhanced event handling\n            this.setupEnhancedEventHandling();\n            \n            console.log('üöÄ Enhanced Signal Integration initialized successfully');\n            \n        } catch (error) {\n            console.error('‚ùå Failed to initialize enhanced features:', error);\n        }\n    }\n    \n    /**\n     * Initialize multi-timeframe validator\n     */\n    async initializeMultiTimeframeValidator() {\n        try {\n            this.multiTimeframeValidator = new MultiTimeframeValidator({\n                timeframes: ['15m', '1h', '1d'],\n                enableRealTimeValidation: true,\n                consensusThreshold: this.config.consensusThreshold,\n                enablePerformanceTracking: true\n            });\n            \n            // Set up validator event handlers\n            this.multiTimeframeValidator.on('signalValidated', (result) => {\n                this.handleValidationResult(result);\n            });\n            \n            this.multiTimeframeValidator.on('validationError', (error) => {\n                console.error('‚ùå Signal validation error:', error);\n            });\n            \n            console.log('‚úÖ Multi-timeframe validator initialized');\n            \n        } catch (error) {\n            console.error('‚ùå Failed to initialize multi-timeframe validator:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Initialize alignment widget\n     */\n    initializeAlignmentWidget() {\n        // Create alignment widget container if it doesn't exist\n        let widgetContainer = document.getElementById('timeframe-alignment-widget');\n        if (!widgetContainer) {\n            widgetContainer = document.createElement('div');\n            widgetContainer.id = 'timeframe-alignment-widget';\n            widgetContainer.style.cssText = `\n                position: fixed;\n                top: 20px;\n                right: 20px;\n                z-index: 1000;\n                background: rgba(0, 0, 0, 0.9);\n                border-radius: 8px;\n                padding: 8px;\n            `;\n            document.body.appendChild(widgetContainer);\n        }\n        \n        // Initialize the widget\n        this.alignmentWidget = new TimeframeAlignmentWidget('timeframe-alignment-widget', {\n            showTimeframeLabels: true,\n            showStrengthBars: true,\n            showConsensusIndicator: true,\n            updateInterval: 1000\n        });\n        \n        // Set up widget event handlers\n        this.alignmentWidget.on('timeframeClicked', (data) => {\n            console.log('üéØ Timeframe clicked:', data);\n            this.emit('timeframeInteraction', data);\n        });\n        \n        console.log('‚úÖ Alignment widget initialized');\n    }\n    \n    /**\n     * Set up enhanced event handling\n     */\n    setupEnhancedEventHandling() {\n        // Override the original signal update handler\n        this.originalHandleSignalUpdate = this.handleSignalUpdate.bind(this);\n        this.handleSignalUpdate = this.enhancedHandleSignalUpdate.bind(this);\n        \n        // Set up periodic alignment updates\n        setInterval(() => {\n            this.updateAlignmentDisplay();\n        }, this.config.updateInterval || 1000);\n    }\n    \n    /**\n     * Enhanced signal update handler with validation\n     */\n    async enhancedHandleSignalUpdate(data) {\n        this.enhancedMetrics.totalSignalsReceived++;\n        \n        try {\n            const signal = this.parseSignalData(data);\n            if (!signal) return;\n            \n            // Quick validation first\n            if (this.multiTimeframeValidator) {\n                const quickCheck = this.multiTimeframeValidator.quickValidate(signal);\n                if (!quickCheck.valid) {\n                    this.handleRejectedSignal(signal, quickCheck.reason, 'quick_validation');\n                    return;\n                }\n            }\n            \n            // Perform full multi-timeframe validation if enabled\n            if (this.config.enableMultiTimeframeValidation && this.multiTimeframeValidator) {\n                await this.performMultiTimeframeValidation(signal);\n            } else {\n                // Fall back to original behavior\n                this.originalHandleSignalUpdate(data);\n            }\n            \n        } catch (error) {\n            console.error('‚ùå Error in enhanced signal handling:', error);\n            // Fall back to original behavior on error\n            this.originalHandleSignalUpdate(data);\n        }\n    }\n    \n    /**\n     * Perform multi-timeframe validation\n     */\n    async performMultiTimeframeValidation(signal) {\n        const startTime = performance.now();\n        \n        try {\n            // Set loading state for the signal\n            this.showSignalValidationStatus(signal, 'validating');\n            \n            // Perform validation with timeout\n            const validationPromise = this.multiTimeframeValidator.validateSignal(signal);\n            const timeoutPromise = new Promise((_, reject) => \n                setTimeout(() => reject(new Error('Validation timeout')), this.config.timeframeValidationTimeout)\n            );\n            \n            const result = await Promise.race([validationPromise, timeoutPromise]);\n            \n            // Record validation time\n            const validationTime = performance.now() - startTime;\n            this.enhancedMetrics.validationTime.push(validationTime);\n            \n            // Handle the validation result\n            this.handleValidationResult(result);\n            \n        } catch (error) {\n            console.error('‚ùå Multi-timeframe validation failed:', error);\n            \n            // Handle validation failure\n            this.handleRejectedSignal(signal, error.message, 'validation_error');\n            \n            // Clear loading state\n            this.hideSignalValidationStatus(signal);\n        }\n    }\n    \n    /**\n     * Handle validation result\n     */\n    handleValidationResult(result) {\n        const { signal, approved, confidence, reason, trendAnalysis } = result;\n        \n        if (approved) {\n            // Signal approved - enhance and process\n            this.handleApprovedSignal(result);\n        } else {\n            // Signal rejected\n            this.handleRejectedSignal(signal, reason, 'consensus_validation');\n        }\n        \n        // Update alignment display\n        if (trendAnalysis && this.alignmentWidget) {\n            this.alignmentWidget.updateAlignment(signal.symbol, trendAnalysis);\n        }\n        \n        // Update performance metrics\n        this.updateEnhancedMetrics(result);\n    }\n    \n    /**\n     * Handle approved signal\n     */\n    handleApprovedSignal(validationResult) {\n        const { signal, confidence, trendAnalysis } = validationResult;\n        \n        // Enhance signal with validation data\n        const enhancedSignal = {\n            ...signal,\n            multiTimeframeValidated: true,\n            validationConfidence: confidence,\n            consensusAchieved: trendAnalysis?.consensus?.consensusAchieved || false,\n            trendAlignment: trendAnalysis?.consensus?.agreement || 0,\n            enhancedStrength: this.calculateEnhancedStrength(signal, validationResult),\n            validationTimestamp: Date.now()\n        };\n        \n        // Store validated signal\n        this.validatedSignals.set(signal.id, enhancedSignal);\n        \n        // Process the enhanced signal\n        this.queueSignal(enhancedSignal);\n        \n        // Show success status\n        this.showSignalValidationStatus(signal, 'approved', confidence);\n        \n        // Update metrics\n        this.enhancedMetrics.signalsValidated++;\n        if (enhancedSignal.consensusAchieved) {\n            this.enhancedMetrics.consensusAchieved++;\n        }\n        \n        console.log(`‚úÖ Signal approved: ${signal.symbol} (${signal.type}) - Confidence: ${(confidence * 100).toFixed(1)}%`);\n    }\n    \n    /**\n     * Handle rejected signal\n     */\n    handleRejectedSignal(signal, reason, stage) {\n        // Store rejected signal for analysis\n        this.rejectedSignals.set(signal.id, {\n            signal,\n            reason,\n            stage,\n            timestamp: Date.now()\n        });\n        \n        // Show rejection status\n        this.showSignalValidationStatus(signal, 'rejected', 0, reason);\n        \n        // Update metrics\n        this.enhancedMetrics.signalsRejected++;\n        \n        console.log(`‚ùå Signal rejected: ${signal.symbol} (${signal.type}) - Reason: ${reason}`);\n        \n        // Emit rejection event\n        this.emit('signalRejected', { signal, reason, stage });\n    }\n    \n    /**\n     * Calculate enhanced signal strength\n     */\n    calculateEnhancedStrength(signal, validationResult) {\n        if (!this.config.adaptiveSignalStrength) {\n            return signal.strength;\n        }\n        \n        let enhancedStrength = signal.strength;\n        \n        // Apply consensus multiplier\n        if (validationResult.trendAnalysis?.consensus?.consensusAchieved) {\n            enhancedStrength *= 1.25; // 25% boost for consensus\n        }\n        \n        // Apply confidence multiplier\n        if (validationResult.confidence > 0.8) {\n            enhancedStrength *= 1.1; // 10% boost for high confidence\n        }\n        \n        // Apply alignment multiplier\n        const alignment = validationResult.trendAnalysis?.consensus?.agreement || 0;\n        if (alignment > 0.8) {\n            enhancedStrength *= 1.15; // 15% boost for strong alignment\n        }\n        \n        return Math.min(1.0, enhancedStrength); // Cap at 1.0\n    }\n    \n    /**\n     * Show signal validation status\n     */\n    showSignalValidationStatus(signal, status, confidence = 0, reason = '') {\n        // Create or update status indicator\n        let statusEl = document.getElementById(`signal-status-${signal.id}`);\n        if (!statusEl) {\n            statusEl = document.createElement('div');\n            statusEl.id = `signal-status-${signal.id}`;\n            statusEl.style.cssText = `\n                position: fixed;\n                top: 50px;\n                right: 20px;\n                background: rgba(0, 0, 0, 0.9);\n                color: white;\n                padding: 8px 12px;\n                border-radius: 4px;\n                font-size: 12px;\n                z-index: 1001;\n                transition: all 0.3s ease;\n                max-width: 300px;\n            `;\n            document.body.appendChild(statusEl);\n        }\n        \n        let statusText = '';\n        let statusColor = '#888';\n        \n        switch (status) {\n            case 'validating':\n                statusText = `üîç Validating ${signal.symbol}...`;\n                statusColor = '#ffa500';\n                break;\n            case 'approved':\n                statusText = `‚úÖ ${signal.symbol} signal approved (${(confidence * 100).toFixed(1)}%)`;\n                statusColor = '#00ff00';\n                break;\n            case 'rejected':\n                statusText = `‚ùå ${signal.symbol} signal rejected: ${reason}`;\n                statusColor = '#ff0000';\n                break;\n        }\n        \n        statusEl.innerHTML = statusText;\n        statusEl.style.borderLeft = `4px solid ${statusColor}`;\n        \n        // Auto-hide after delay (except for validating status)\n        if (status !== 'validating') {\n            setTimeout(() => {\n                if (statusEl && statusEl.parentNode) {\n                    statusEl.style.opacity = '0';\n                    setTimeout(() => {\n                        if (statusEl && statusEl.parentNode) {\n                            statusEl.parentNode.removeChild(statusEl);\n                        }\n                    }, 300);\n                }\n            }, 3000);\n        }\n    }\n    \n    /**\n     * Hide signal validation status\n     */\n    hideSignalValidationStatus(signal) {\n        const statusEl = document.getElementById(`signal-status-${signal.id}`);\n        if (statusEl && statusEl.parentNode) {\n            statusEl.parentNode.removeChild(statusEl);\n        }\n    }\n    \n    /**\n     * Update alignment display\n     */\n    updateAlignmentDisplay() {\n        if (!this.alignmentWidget || !this.multiTimeframeValidator) return;\n        \n        // Get current symbol (you might need to implement symbol selection logic)\n        const currentSymbol = this.getCurrentSymbol();\n        if (currentSymbol) {\n            const alignment = this.multiTimeframeValidator.getTrendAlignment(currentSymbol);\n            const consensus = this.multiTimeframeValidator.getTrendConsensus(currentSymbol);\n            \n            if (alignment || consensus) {\n                this.alignmentWidget.updateAlignment(currentSymbol, {\n                    trends: alignment?.trends || {},\n                    consensus: consensus || {}\n                });\n            }\n        }\n    }\n    \n    /**\n     * Get current symbol (implement based on your UI logic)\n     */\n    getCurrentSymbol() {\n        // This should return the currently selected symbol\n        // You might get this from a dropdown, active tab, or other UI element\n        const symbolInput = document.getElementById('symbol-input');\n        if (symbolInput) {\n            return symbolInput.value || 'AAPL'; // Default fallback\n        }\n        return 'AAPL'; // Default fallback\n    }\n    \n    /**\n     * Update enhanced metrics\n     */\n    updateEnhancedMetrics(result) {\n        // Calculate average validation time\n        if (this.enhancedMetrics.validationTime.length > 100) {\n            this.enhancedMetrics.validationTime = this.enhancedMetrics.validationTime.slice(-50);\n        }\n        \n        // Calculate performance improvement\n        const approvalRate = this.enhancedMetrics.totalSignalsReceived > 0 ?\n            this.enhancedMetrics.signalsValidated / this.enhancedMetrics.totalSignalsReceived : 0;\n        \n        const consensusRate = this.enhancedMetrics.signalsValidated > 0 ?\n            this.enhancedMetrics.consensusAchieved / this.enhancedMetrics.signalsValidated : 0;\n        \n        // Estimate performance improvement (this would be better with historical data)\n        this.enhancedMetrics.performanceImprovement = consensusRate * 0.25; // Up to 25% improvement\n    }\n    \n    /**\n     * Get enhanced performance statistics\n     */\n    getEnhancedPerformanceStats() {\n        const avgValidationTime = this.enhancedMetrics.validationTime.length > 0 ?\n            this.enhancedMetrics.validationTime.reduce((a, b) => a + b, 0) / this.enhancedMetrics.validationTime.length : 0;\n        \n        const approvalRate = this.enhancedMetrics.totalSignalsReceived > 0 ?\n            (this.enhancedMetrics.signalsValidated / this.enhancedMetrics.totalSignalsReceived * 100) : 0;\n        \n        const consensusRate = this.enhancedMetrics.signalsValidated > 0 ?\n            (this.enhancedMetrics.consensusAchieved / this.enhancedMetrics.signalsValidated * 100) : 0;\n        \n        return {\n            ...this.enhancedMetrics,\n            avgValidationTime: avgValidationTime.toFixed(2),\n            approvalRate: approvalRate.toFixed(2),\n            consensusRate: consensusRate.toFixed(2),\n            estimatedImprovement: (this.enhancedMetrics.performanceImprovement * 100).toFixed(1)\n        };\n    }\n    \n    /**\n     * Get validation summary\n     */\n    getValidationSummary() {\n        return {\n            validatedSignals: this.validatedSignals.size,\n            rejectedSignals: this.rejectedSignals.size,\n            alignmentData: Array.from(this.alignmentStatus.entries()),\n            performanceStats: this.getEnhancedPerformanceStats(),\n            multiTimeframeStatus: this.multiTimeframeValidator ? this.multiTimeframeValidator.getStatus() : null\n        };\n    }\n    \n    /**\n     * Update signal outcome for learning\n     */\n    updateSignalOutcome(signalId, successful, profitLoss = null) {\n        // Call parent method\n        super.updateSignalOutcome && super.updateSignalOutcome(signalId, successful, profitLoss);\n        \n        // Update multi-timeframe validator for learning\n        if (this.multiTimeframeValidator) {\n            this.multiTimeframeValidator.updateSignalOutcome(signalId, successful, profitLoss);\n        }\n    }\n    \n    /**\n     * Subscribe to symbols with multi-timeframe support\n     */\n    subscribeToSymbolsEnhanced(symbols) {\n        // Subscribe for regular data\n        this.subscribeToSymbols && this.subscribeToSymbols(symbols);\n        \n        // Subscribe for multi-timeframe data\n        if (this.multiTimeframeValidator) {\n            this.multiTimeframeValidator.subscribeToSymbols(symbols);\n        }\n    }\n    \n    /**\n     * Enhanced configuration update\n     */\n    updateConfigEnhanced(newConfig) {\n        // Update parent config\n        this.updateConfig && this.updateConfig(newConfig);\n        \n        // Update enhanced config\n        this.config = { ...this.config, ...newConfig };\n        \n        // Update multi-timeframe validator config if available\n        if (this.multiTimeframeValidator && newConfig.multiTimeframe) {\n            // Implementation would depend on the validator's config update method\n        }\n        \n        // Update alignment widget config if available\n        if (this.alignmentWidget && newConfig.alignmentWidget) {\n            this.alignmentWidget.updateConfig(newConfig.alignmentWidget);\n        }\n    }\n    \n    /**\n     * Enhanced cleanup\n     */\n    destroy() {\n        // Call parent destroy\n        super.destroy && super.destroy();\n        \n        // Clean up enhanced components\n        if (this.multiTimeframeValidator) {\n            this.multiTimeframeValidator.shutdown();\n        }\n        \n        if (this.alignmentWidget) {\n            this.alignmentWidget.destroy();\n        }\n        \n        // Clear enhanced data\n        this.validatedSignals.clear();\n        this.rejectedSignals.clear();\n        this.alignmentStatus.clear();\n        \n        console.log('üóëÔ∏è Enhanced Signal Integration destroyed');\n    }\n}\n\n// Export for module systems\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = EnhancedSignalIntegration;\n}\n\n// Global assignment for direct HTML inclusion\nif (typeof window !== 'undefined') {\n    window.EnhancedSignalIntegration = EnhancedSignalIntegration;\n}"