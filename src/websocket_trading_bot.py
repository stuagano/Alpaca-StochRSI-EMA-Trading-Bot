"""
Enhanced trading bot with WebSocket integration for real-time notifications and monitoring.
This extends the existing trading bot with WebSocket broadcasting capabilities.
"""

import time
import threading
import logging
from datetime import datetime
from typing import Optional, Dict, Any, List
from dataclasses import dataclass

from trading_bot import TradingBot  # Import existing trading bot
from src.trading_websocket_integration import TradingWebSocketService

logger = logging.getLogger(__name__)

@dataclass
class TradeNotification:
    """Trade notification structure"""
    symbol: str
    action: str  # 'buy', 'sell', 'signal'
    price: float
    quantity: Optional[float] = None
    signal_strength: Optional[float] = None
    indicators: Optional[Dict[str, Any]] = None
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()

class WebSocketTradingBot(TradingBot):
    """Enhanced trading bot with WebSocket real-time notifications"""
    
    def __init__(self, data_manager, strategy, websocket_service: Optional[TradingWebSocketService] = None):
        super().__init__(data_manager, strategy)
        self.websocket_service = websocket_service
        
        # WebSocket-specific settings
        self.enable_realtime_notifications = True
        self.notification_throttle = 1.0  # Minimum seconds between notifications
        self.last_notifications = {}  # Track last notification times
        
        # Performance tracking
        self.trade_statistics = {
            'signals_generated': 0,
            'trades_executed': 0,
            'notifications_sent': 0,
            'websocket_broadcasts': 0,
            'start_time': time.time()
        }
        
        # Background monitoring
        self.monitoring_thread = None
        self.monitoring_active = False
        
        logger.info("WebSocket Trading Bot initialized with real-time notifications")
    
    def set_websocket_service(self, websocket_service: TradingWebSocketService):
        """Set the WebSocket service for real-time notifications"""
        self.websocket_service = websocket_service
        logger.info("WebSocket service attached to trading bot")
    
    def run(self):
        """Enhanced run method with WebSocket monitoring"""
        logger.info("WebSocket Trading Bot started...")
        
        # Start background monitoring
        self.start_monitoring()
        
        try:\n            # Call parent run method\n            super().run()\n        finally:\n            # Ensure monitoring is stopped\n            self.stop_monitoring()\n    \n    def start_monitoring(self):\n        \"\"\"Start background monitoring and WebSocket broadcasting\"\"\"\n        if self.monitoring_active:\n            return\n        \n        self.monitoring_active = True\n        self.monitoring_thread = threading.Thread(\n            target=self._monitoring_loop,\n            daemon=True,\n            name=\"WebSocketBotMonitoring\"\n        )\n        self.monitoring_thread.start()\n        \n        logger.info(\"WebSocket monitoring started\")\n    \n    def stop_monitoring(self):\n        \"\"\"Stop background monitoring\"\"\"\n        self.monitoring_active = False\n        \n        if self.monitoring_thread and self.monitoring_thread.is_alive():\n            self.monitoring_thread.join(timeout=5)\n        \n        logger.info(\"WebSocket monitoring stopped\")\n    \n    def _monitoring_loop(self):\n        \"\"\"Background monitoring loop for performance and health\"\"\"\n        while self.monitoring_active:\n            try:\n                # Broadcast system health if WebSocket service is available\n                if self.websocket_service:\n                    health_data = {\n                        'bot_status': 'running' if self.monitoring_active else 'stopped',\n                        'statistics': self.get_trading_statistics(),\n                        'timestamp': time.time()\n                    }\n                    \n                    self.websocket_service.websocket_server._broadcast_to_stream(\n                        self.websocket_service.websocket_server.StreamType.SYSTEM_HEALTH,\n                        health_data\n                    )\n                \n                # Log statistics periodically\n                if int(time.time()) % 60 == 0:  # Every minute\n                    stats = self.get_trading_statistics()\n                    logger.info(f\"Bot stats: {stats['signals_generated']} signals, \"\n                              f\"{stats['trades_executed']} trades, \"\n                              f\"{stats['notifications_sent']} notifications\")\n                \n                time.sleep(5)  # Monitor every 5 seconds\n                \n            except Exception as e:\n                logger.error(f\"Error in monitoring loop: {e}\")\n                time.sleep(5)\n    \n    def run_strategy(self):\n        \"\"\"Enhanced strategy execution with WebSocket notifications\"\"\"\n        if not self.can_place_new_trade():\n            logger.info(\"Maximum number of trades reached. No new trades will be placed.\")\n            return\n\n        for ticker in self.tickers:\n            if not self.can_place_new_trade():\n                break\n            \n            try:\n                # Get historical data\n                df = self.data_manager.get_historical_data(\n                    ticker, \n                    timeframe=self.risk_management_params.get('timeframe', '1Min'), \n                    limit=self.risk_management_params.get('candle_lookback_period', 100)\n                )\n                \n                if df.empty:\n                    continue\n\n                # Generate signal\n                signal = self.strategy.generate_signal(df)\n                \n                # Broadcast signal via WebSocket\n                self._broadcast_signal_update(ticker, signal, df)\n                \n                # Execute trade if signal is positive\n                if signal == 1:\n                    success = self.enter_position(ticker, df)\n                    if success:\n                        self.trade_statistics['trades_executed'] += 1\n                \n                self.trade_statistics['signals_generated'] += 1\n                \n            except Exception as e:\n                logger.error(f\"Error processing {ticker}: {e}\")\n    \n    def enter_position(self, ticker: str, df) -> bool:\n        \"\"\"Enhanced position entry with WebSocket notifications\"\"\"\n        try:\n            price = self.data_manager.get_latest_price(ticker)\n            if not price:\n                return False\n\n            # Enhanced risk management (from parent class)\n            if self.enable_enhanced_risk_management:\n                optimal_size_recommendation = self.enhanced_risk_manager.calculate_optimal_position_size(\n                    symbol=ticker,\n                    entry_price=price\n                )\n                \n                portfolio_value = self._get_portfolio_value()\n                quantity = (optimal_size_recommendation.risk_adjusted_size * portfolio_value) / price\n                \n                stop_loss_price = self.calculate_stop_loss(price, df)\n                validation_result = self.enhanced_risk_manager.validate_position_size(\n                    symbol=ticker,\n                    proposed_size=quantity,\n                    entry_price=price,\n                    stop_loss_price=stop_loss_price\n                )\n                \n                if not validation_result.approved:\n                    logger.warning(f\"Position rejected by risk manager for {ticker}: {validation_result.violations}\")\n                    \n                    # Broadcast rejection notification\n                    self._broadcast_trade_notification(\n                        ticker, 'rejected', price, \n                        reason='risk_management',\n                        violations=validation_result.violations\n                    )\n                    \n                    return False\n                \n                # Use risk manager's recommended quantity\n                quantity = validation_result.recommended_size\n            else:\n                # Fallback to legacy position sizing\n                quantity = self.calculate_position_size(ticker, price)\n\n            # Place the order\n            order = self.place_buy_order(ticker, quantity, price)\n            \n            if order:\n                # Broadcast successful trade notification\n                self._broadcast_trade_notification(\n                    ticker, 'buy', price, quantity,\n                    order_id=order.get('id'),\n                    risk_adjusted=self.enable_enhanced_risk_management\n                )\n                \n                # Broadcast order update via WebSocket\n                if self.websocket_service:\n                    order_data = {\n                        'id': order.get('id'),\n                        'symbol': ticker,\n                        'side': 'buy',\n                        'qty': quantity,\n                        'status': 'submitted',\n                        'submitted_at': datetime.now().isoformat()\n                    }\n                    self.websocket_service.broadcast_order_update(order_data)\n                    self.trade_statistics['websocket_broadcasts'] += 1\n                \n                logger.info(f\"✅ Buy order placed for {ticker}: {quantity} shares at ${price}\")\n                return True\n            else:\n                logger.error(f\"❌ Failed to place buy order for {ticker}\")\n                \n                # Broadcast failed trade notification\n                self._broadcast_trade_notification(\n                    ticker, 'failed', price, quantity,\n                    reason='order_placement_failed'\n                )\n                \n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error entering position for {ticker}: {e}\")\n            \n            # Broadcast error notification\n            if self.websocket_service:\n                error_data = {\n                    'symbol': ticker,\n                    'action': 'error',\n                    'error': str(e),\n                    'timestamp': time.time()\n                }\n                self.websocket_service.websocket_server.broadcast_signal(ticker, error_data)\n            \n            return False\n    \n    def _broadcast_signal_update(self, ticker: str, signal: int, df):\n        \"\"\"Broadcast trading signal update via WebSocket\"\"\"\n        if not self.websocket_service or not self.enable_realtime_notifications:\n            return\n        \n        try:\n            # Throttle notifications\n            current_time = time.time()\n            last_time = self.last_notifications.get(f\"signal_{ticker}\", 0)\n            \n            if current_time - last_time < self.notification_throttle:\n                return\n            \n            # Calculate indicators for signal context\n            config = self.load_config() if hasattr(self, 'load_config') else None\n            if config:\n                config_dict = self._convert_config_for_indicators(config)\n                indicators = self.data_manager.calculate_indicators(df, config_dict)\n            else:\n                indicators = {}\n            \n            # Prepare signal data\n            signal_data = {\n                'symbol': ticker,\n                'signal': signal,\n                'signal_strength': self._calculate_signal_strength(signal, indicators),\n                'action': 'BUY' if signal == 1 else 'HOLD',\n                'indicators': indicators,\n                'price': self.data_manager.get_latest_price(ticker),\n                'timestamp': current_time\n            }\n            \n            # Broadcast via WebSocket\n            self.websocket_service.websocket_server.broadcast_signal(ticker, signal_data)\n            \n            # Update notification tracking\n            self.last_notifications[f\"signal_{ticker}\"] = current_time\n            self.trade_statistics['notifications_sent'] += 1\n            self.trade_statistics['websocket_broadcasts'] += 1\n            \n        except Exception as e:\n            logger.error(f\"Error broadcasting signal update for {ticker}: {e}\")\n    \n    def _broadcast_trade_notification(self, ticker: str, action: str, price: float, \n                                    quantity: Optional[float] = None, **kwargs):\n        \"\"\"Broadcast trade notification via WebSocket\"\"\"\n        if not self.websocket_service or not self.enable_realtime_notifications:\n            return\n        \n        try:\n            notification = {\n                'symbol': ticker,\n                'action': action,\n                'price': price,\n                'quantity': quantity,\n                'timestamp': time.time(),\n                **kwargs\n            }\n            \n            # Broadcast as signal update\n            self.websocket_service.websocket_server.broadcast_signal(ticker, notification)\n            \n            # Also broadcast as order update if it's a trade\n            if action in ['buy', 'sell'] and quantity:\n                order_data = {\n                    'symbol': ticker,\n                    'side': action,\n                    'qty': quantity,\n                    'price': price,\n                    'status': 'executed',\n                    'timestamp': time.time()\n                }\n                self.websocket_service.websocket_server.broadcast_order_update(order_data)\n            \n            self.trade_statistics['notifications_sent'] += 1\n            self.trade_statistics['websocket_broadcasts'] += 1\n            \n        except Exception as e:\n            logger.error(f\"Error broadcasting trade notification for {ticker}: {e}\")\n    \n    def _convert_config_for_indicators(self, config) -> Dict:\n        \"\"\"Convert unified config to legacy format for indicators\"\"\"\n        try:\n            return {\n                'indicators': {\n                    'stochRSI': \"True\" if config.indicators.stochRSI.enabled else \"False\",\n                    'stochRSI_params': {\n                        'rsi_length': config.indicators.stochRSI.rsi_length,\n                        'stoch_length': config.indicators.stochRSI.stoch_length,\n                        'K': config.indicators.stochRSI.K,\n                        'D': config.indicators.stochRSI.D,\n                        'lower_band': config.indicators.stochRSI.lower_band,\n                        'upper_band': config.indicators.stochRSI.upper_band\n                    },\n                    'EMA': \"True\" if config.indicators.EMA.enabled else \"False\",\n                    'EMA_params': {\n                        'ema_period': config.indicators.EMA.ema_period\n                    }\n                }\n            }\n        except Exception as e:\n            logger.error(f\"Error converting config: {e}\")\n            return {'indicators': {}}\n    \n    def _calculate_signal_strength(self, signal: int, indicators: Dict) -> float:\n        \"\"\"Calculate signal strength from indicators\"\"\"\n        try:\n            if signal == 0:\n                return 0.0\n            \n            strength = 0.5  # Base strength\n            \n            # StochRSI contribution\n            if 'StochRSI_K' in indicators and 'StochRSI_D' in indicators:\n                k = indicators['StochRSI_K']\n                d = indicators['StochRSI_D']\n                \n                # Stronger signal when K > D and both are low\n                if k > d and k < 30:\n                    strength += 0.3\n                elif k > d:\n                    strength += 0.1\n            \n            # EMA contribution\n            if 'EMA' in indicators:\n                price = self.data_manager.get_latest_price(self.tickers[0]) if self.tickers else None\n                if price:\n                    ema = indicators['EMA']\n                    if price > ema:\n                        strength += 0.2\n            \n            return min(strength, 1.0)\n            \n        except Exception as e:\n            logger.debug(f\"Error calculating signal strength: {e}\")\n            return 0.5\n    \n    def get_trading_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get trading bot statistics\"\"\"\n        uptime = time.time() - self.trade_statistics['start_time']\n        \n        return {\n            **self.trade_statistics,\n            'uptime_seconds': uptime,\n            'signals_per_minute': self.trade_statistics['signals_generated'] / max(uptime / 60, 1),\n            'trade_success_rate': (\n                self.trade_statistics['trades_executed'] / \n                max(self.trade_statistics['signals_generated'], 1)\n            ),\n            'websocket_enabled': self.websocket_service is not None,\n            'realtime_notifications': self.enable_realtime_notifications\n        }\n    \n    def enable_websocket_notifications(self, enabled: bool = True):\n        \"\"\"Enable or disable WebSocket notifications\"\"\"\n        self.enable_realtime_notifications = enabled\n        logger.info(f\"WebSocket notifications {'enabled' if enabled else 'disabled'}\")\n    \n    def set_notification_throttle(self, seconds: float):\n        \"\"\"Set minimum time between notifications\"\"\"\n        self.notification_throttle = max(0.1, seconds)\n        logger.info(f\"Notification throttle set to {self.notification_throttle}s\")\n\n# Factory function for easy integration\ndef create_websocket_trading_bot(data_manager, strategy, websocket_service=None):\n    \"\"\"Create a WebSocket-enabled trading bot\"\"\"\n    bot = WebSocketTradingBot(data_manager, strategy, websocket_service)\n    \n    logger.info(\"WebSocket Trading Bot created successfully\")\n    logger.info(f\"Real-time notifications: {'enabled' if websocket_service else 'disabled'}\")\n    \n    return bot\n\n# Integration helper for existing systems\ndef upgrade_existing_bot_to_websocket(existing_bot: TradingBot, websocket_service: TradingWebSocketService):\n    \"\"\"Upgrade an existing trading bot to use WebSocket notifications\"\"\"\n    \n    # Create new WebSocket bot with same configuration\n    websocket_bot = WebSocketTradingBot(\n        existing_bot.data_manager,\n        existing_bot.strategy,\n        websocket_service\n    )\n    \n    # Copy relevant settings\n    websocket_bot.tickers = existing_bot.tickers\n    websocket_bot.api = existing_bot.api\n    websocket_bot.risk_management_params = existing_bot.risk_management_params\n    \n    if hasattr(existing_bot, 'enhanced_risk_manager'):\n        websocket_bot.enhanced_risk_manager = existing_bot.enhanced_risk_manager\n        websocket_bot.risk_config = existing_bot.risk_config\n        websocket_bot.enable_enhanced_risk_management = existing_bot.enable_enhanced_risk_management\n    \n    logger.info(\"Existing trading bot upgraded with WebSocket capabilities\")\n    \n    return websocket_bot