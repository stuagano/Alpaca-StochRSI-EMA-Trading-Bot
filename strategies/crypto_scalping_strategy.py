"""
High-Frequency Crypto Day Trading Strategy
Focuses on volatility, quick gains, and rapid position turnover
WITH COMPREHENSIVE ERROR HANDLING AND TRADE LOGGING
"""

import numpy as np
import pandas as pd
import asyncio
import websocket
import json
import math
import time
import os
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from decimal import Decimal, ROUND_DOWN
from typing import Any, Dict, Iterable, List, Optional, Set, Tuple
from concurrent.futures import ThreadPoolExecutor
import logging
from threading import Lock
from enum import Enum
from alpaca.common.exceptions import APIError

from utils.trade_store import TradeStore
from config.unified_config import CryptoScannerConfig, TradingConfig

try:
    from prometheus_client import Counter, Gauge  # type: ignore
except ImportError:  # pragma: no cover - optional dependency
    Counter = Gauge = None  # type: ignore[assignment]


SCANNER_SCAN_METRIC_NAME = "crypto_scanner_scans_total"
SCANNER_ERROR_METRIC_NAME = "crypto_scanner_errors_total"
SCANNER_TRACKED_SYMBOLS_METRIC_NAME = "crypto_scanner_tracked_pairs"
SCANNER_SIGNALS_METRIC_NAME = "crypto_scanner_signals_last"
SCANNER_LAST_RUN_METRIC_NAME = "crypto_scanner_last_run_timestamp"

SCANNER_SCAN_COUNTER = Counter(
    SCANNER_SCAN_METRIC_NAME,
    "Total number of crypto scanner runs",
) if Counter else None

SCANNER_ERROR_COUNTER = Counter(
    SCANNER_ERROR_METRIC_NAME,
    "Total number of crypto scanner errors",
) if Counter else None

SCANNER_TRACKED_SYMBOLS_GAUGE = Gauge(
    SCANNER_TRACKED_SYMBOLS_METRIC_NAME,
    "Number of symbols currently tracked by the crypto scanner",
) if Gauge else None

SCANNER_SIGNALS_GAUGE = Gauge(
    SCANNER_SIGNALS_METRIC_NAME,
    "Number of signals generated by the most recent crypto scan",
) if Gauge else None

SCANNER_LAST_RUN_GAUGE = Gauge(
    SCANNER_LAST_RUN_METRIC_NAME,
    "Unix timestamp of the most recent crypto scanner run",
) if Gauge else None


def _metric_inc(metric: Optional[Counter], amount: float = 1.0) -> None:
    """Increase a Prometheus counter when available."""

    if metric is None:
        return

    try:
        metric.inc(amount)
    except Exception:  # pragma: no cover - defensive guard
        logging.getLogger(__name__).debug("Failed to increment metric", exc_info=True)


def _metric_set(metric: Optional[Gauge], value: float) -> None:
    """Set a Prometheus gauge when available."""

    if metric is None:
        return

    try:
        metric.set(value)
    except Exception:  # pragma: no cover - defensive guard
        logging.getLogger(__name__).debug("Failed to set metric", exc_info=True)

# Configure structured logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-8s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

@dataclass
class TradeLog:
    """Comprehensive trade log entry with all required fields"""
    timestamp: str
    action: str  # 'BUY' or 'SELL'
    symbol: str
    quantity: float
    price: float
    status: str  # 'filled', 'partially_filled', 'failed'
    error_notes: str = ""
    order_id: str = ""
    pnl: float = 0.0
    execution_time_ms: int = 0
    
    def to_console_string(self) -> str:
        """Format for clear console output"""
        status_emoji = {
            "filled": "‚úÖ",
            "partially_filled": "‚ö†Ô∏è",
            "failed": "‚ùå",
            "pending": "‚è≥"
        }.get(self.status, "‚ùì")
        
        action_color = "\033[92m" if self.action == "BUY" else "\033[91m"
        reset_color = "\033[0m"
        
        return (
            f"{status_emoji} {self.timestamp} | "
            f"{action_color}{self.action:4s}{reset_color} | "
            f"{self.symbol:10s} | "
            f"Qty: {self.quantity:8.4f} | "
            f"Price: ${self.price:10.2f} | "
            f"Status: {self.status:15s} | "
            f"P&L: ${self.pnl:+8.2f} | "
            f"Exec: {self.execution_time_ms}ms | "
            f"{self.error_notes}"
        )

@dataclass
class CryptoSignal:
    symbol: str
    action: str  # 'buy', 'sell', 'hold'
    confidence: float
    price: float
    volatility: float
    volume_surge: bool
    momentum: float
    target_profit: float
    stop_loss: float
    timestamp: datetime

class CryptoVolatilityScanner:
    """Scans for high volatility crypto pairs suitable for day trading"""

    def __init__(
        self,
        config: Optional[CryptoScannerConfig] = None,
        enabled_symbols: Optional[List[str]] = None,
    ):
        self.config = config or CryptoScannerConfig()
        self.lock = Lock()

        self.configured_universe = self._merge_symbol_lists([], self.config.universe)
        self.default_pairs = list(self.configured_universe)

        initial_overrides = enabled_symbols or []
        merged_symbols = self._merge_symbol_lists(self.configured_universe, initial_overrides)

        self.high_volume_pairs = merged_symbols
        self.enabled_trading_symbols: Set[str] = set(merged_symbols)
        _metric_set(SCANNER_TRACKED_SYMBOLS_GAUGE, float(len(self.high_volume_pairs)))

        # Scanner thresholds sourced from configuration
        self.min_24h_volume = self.config.min_24h_volume
        self.min_volatility = self.config.min_volatility
        self.max_spread = self.config.max_spread

        self.price_data: Dict[str, List[float]] = {}
        self.volatility_data: Dict[str, float] = {}
        self.volume_data: Dict[str, List[float]] = {}

        logger.info(
            "Initialized crypto scanner with %d configured symbols (%d defaults, %d overrides)",
            len(self.high_volume_pairs),
            len(self.configured_universe),
            max(0, len(self.high_volume_pairs) - len(self.configured_universe)),
        )

    @staticmethod
    def _normalize_symbol(symbol: str) -> str:
        """Normalise symbols to scanner format."""

        return symbol.replace("/", "").upper()

    @classmethod
    def _merge_symbol_lists(
        cls,
        defaults: Iterable[str],
        overrides: Iterable[str],
    ) -> List[str]:
        """Combine default and override symbols while preserving order."""

        merged: List[str] = []
        seen: Set[str] = set()

        for raw_symbol in list(defaults) + list(overrides):
            if not raw_symbol:
                continue

            normalized = cls._normalize_symbol(raw_symbol)
            if normalized not in seen:
                merged.append(normalized)
                seen.add(normalized)

        return merged
    
    def update_enabled_symbols(
        self,
        enabled_symbols: List[str],
        *,
        merge_with_defaults: bool = True,
    ) -> None:
        """Update the list of symbols enabled for trading."""

        with self.lock:
            base = self.configured_universe if merge_with_defaults else []
            merged = self._merge_symbol_lists(base, enabled_symbols)

            self.enabled_trading_symbols = set(merged)
            self.high_volume_pairs = merged

            logger.info(
                "Updated enabled trading symbols: %d total (defaults merged: %s)",
                len(self.enabled_trading_symbols),
                merge_with_defaults,
            )
            logger.info(
                "Scanner now tracking high volume pairs: %s",
                ", ".join(self.high_volume_pairs),
            )
            _metric_set(SCANNER_TRACKED_SYMBOLS_GAUGE, float(len(self.high_volume_pairs)))

    def get_enabled_symbols(self) -> List[str]:
        """Get list of currently enabled trading symbols"""
        with self.lock:
            return list(self.high_volume_pairs)
    
    def fetch_all_crypto_assets(self, api) -> List[str]:
        """Fetch all available crypto assets from Alpaca"""
        try:
            # Try the alpaca_trade_api.REST method first
            if hasattr(api, 'list_assets'):
                # Using alpaca_trade_api.REST
                assets = api.list_assets(status='active', asset_class='crypto')
                crypto_symbols = []
                for asset in assets:
                    symbol = asset.symbol
                    # Only include USD pairs for trading
                    if 'USD' in symbol and len(symbol) <= 10:
                        # Convert to slash format if needed for API calls later
                        crypto_symbols.append(symbol)
                
                logger.info(f"üì° Fetched {len(crypto_symbols)} crypto assets from Alpaca")
                return sorted(crypto_symbols)
            else:
                # Try newer alpaca-py SDK
                from alpaca.trading.requests import GetAssetsRequest
                from alpaca.trading.enums import AssetClass, AssetStatus

                search_params = GetAssetsRequest(
                    status=AssetStatus.ACTIVE,
                    asset_class=AssetClass.CRYPTO
                )
                assets = api.get_all_assets(search_params)

                crypto_symbols = []
                for asset in assets:
                    symbol = asset.symbol
                    if 'USD' in symbol and len(symbol) <= 10:
                        crypto_symbols.append(symbol)

                logger.info(f"üì° Fetched {len(crypto_symbols)} crypto assets from Alpaca")
                return sorted(crypto_symbols)

        except Exception as e:
            logger.error(f"Failed to fetch crypto assets: {e}")
            # Fallback to default pairs
            return self.default_pairs
    
    def calculate_market_volatility(self, api, symbols: List[str], lookback_hours: int = 24) -> Dict[str, float]:
        """Calculate 24h volatility for all symbols using Alpaca data client"""
        volatility_scores = {}

        try:
            from alpaca.data.historical import CryptoHistoricalDataClient
            from alpaca.data.requests import CryptoBarsRequest
            from alpaca.data.timeframe import TimeFrame, TimeFrameUnit
            from datetime import datetime, timedelta

            # Create data client (free tier, no auth needed for crypto data)
            data_client = CryptoHistoricalDataClient()

            # Calculate timeframe
            end_time = datetime.now()
            start_time = end_time - timedelta(hours=lookback_hours)

            for symbol in symbols:
                try:
                    # Create bars request
                    request_params = CryptoBarsRequest(
                        symbol_or_symbols=[symbol],
                        timeframe=TimeFrame(1, TimeFrameUnit.Minute),
                        start=start_time,
                        end=end_time
                    )

                    # Get historical bars
                    bars_response = data_client.get_crypto_bars(request_params)

                    if symbol not in bars_response.data or len(bars_response.data[symbol]) < 50:
                        continue

                    # Extract price data
                    bars = bars_response.data[symbol]
                    prices = [float(bar.close) for bar in bars]

                    if len(prices) < 2:
                        continue

                    # Calculate price volatility
                    volatility = self.calculate_volatility(prices)

                    # Calculate 24h price change percentage
                    price_change_pct = abs((prices[-1] - prices[0]) / prices[0]) * 100

                    # Combine volatility metrics (favor both volatility and price movement)
                    combined_score = (volatility * 0.7) + (price_change_pct * 0.3)
                    volatility_scores[symbol] = combined_score

                except Exception as e:
                    logger.debug(f"Could not calculate volatility for {symbol}: {e}")
                    continue

        except Exception as e:
            logger.error(f"Failed to create data client: {e}")
            # Fallback to simulated volatility
            for symbol in symbols[:5]:  # Limit to top 5 default symbols
                volatility_scores[symbol] = np.random.uniform(0.001, 0.01)

        return volatility_scores
    
    def select_top_volatile_pairs(self, api, target_count: int = 5) -> List[str]:
        """Dynamically select the most volatile crypto pairs"""
        try:
            # Fetch all available crypto assets
            all_symbols = self.fetch_all_crypto_assets(api)
            
            if not all_symbols:
                logger.warning("No crypto symbols found, using defaults")
                return self.default_pairs[:target_count]
            
            # Calculate volatility for all symbols
            logger.info(f"üîç Analyzing volatility for {len(all_symbols)} crypto pairs...")
            volatility_scores = self.calculate_market_volatility(api, all_symbols)
            
            if not volatility_scores:
                logger.warning("No volatility data available, using defaults")
                return self.default_pairs[:target_count]
            
            # Sort by volatility score (highest first)
            sorted_pairs = sorted(volatility_scores.items(), key=lambda x: x[1], reverse=True)
            
            # Select top N most volatile pairs
            top_pairs = [symbol for symbol, score in sorted_pairs[:target_count]]
            
            logger.info(f"üéØ Selected top {len(top_pairs)} volatile crypto pairs:")
            for i, (symbol, score) in enumerate(sorted_pairs[:target_count]):
                logger.info(f"  {i+1}. {symbol}: Volatility Score {score:.4f}")
            
            return top_pairs
            
        except Exception as e:
            logger.error(f"Failed to select volatile pairs: {e}")
            return self.default_pairs[:target_count]
        
    def calculate_volatility(self, prices: List[float], window: int = 20) -> float:
        """Calculate price volatility using standard deviation"""
        # Use smaller window if not enough data, minimum 3 points
        actual_window = min(window, len(prices))
        if actual_window < 3:
            return 0.0
        
        returns = np.diff(np.log(prices[-actual_window:]))
        return np.std(returns) * np.sqrt(1440)  # Annualized for 1-minute data
    
    def detect_volume_surge(self, volumes: List[float], window: int = 10) -> bool:
        """Detect if current volume is significantly higher than average"""
        if len(volumes) < window + 1:
            return False
        
        recent_avg = np.mean(volumes[-window-1:-1])
        current_volume = volumes[-1]
        
        return current_volume > recent_avg * 1.1  # Only 10% above average (much more aggressive)
    
    def calculate_momentum(self, prices: List[float], period: int = 14) -> float:
        """Calculate price momentum using RSI-like indicator"""
        if len(prices) < period + 1:
            return 0.5
        
        changes = np.diff(prices[-period-1:])
        gains = np.where(changes > 0, changes, 0)
        losses = np.where(changes < 0, -changes, 0)
        
        avg_gain = np.mean(gains)
        avg_loss = np.mean(losses)
        
        if avg_loss == 0:
            return 1.0
        
        rs = avg_gain / avg_loss
        momentum = rs / (1 + rs)
        
        return momentum
    
    def scan_for_opportunities(self) -> List[CryptoSignal]:
        """Scan all crypto pairs for day trading opportunities - ULTRA AGGRESSIVE MODE"""
        signals = []

        with self.lock:
            _metric_inc(SCANNER_SCAN_COUNTER)
            _metric_set(SCANNER_LAST_RUN_GAUGE, float(time.time()))
            _metric_set(SCANNER_TRACKED_SYMBOLS_GAUGE, float(len(self.high_volume_pairs)))
            logger.info(f"üîç Scanning {len(self.high_volume_pairs)} symbols for opportunities...")
            
            # DEBUG: Print all available price data keys
            logger.info(f"üìä Price data available for: {list(self.price_data.keys())}")
            logger.info(f"üìä Expected symbols: {self.high_volume_pairs}")
            
            for symbol in self.high_volume_pairs:
                try:
                    if symbol not in self.price_data:
                        logger.info(f"  ‚ùå {symbol}: No price data available")
                        continue
                    
                    prices = self.price_data[symbol]
                    volumes = self.volume_data.get(symbol, [])
                    
                    if len(prices) < 2:  # MINIMAL requirement for ultra-fast signals
                        logger.info(f"  ‚ùå {symbol}: Insufficient price data ({len(prices)} points)")
                        continue
                    
                    current_price = prices[-1]
                    volatility = self.calculate_volatility(prices)
                    volume_surge = self.detect_volume_surge(volumes)
                    momentum = self.calculate_momentum(prices)
                    
                    logger.info(f"  üìä {symbol}: Price=${current_price:.4f}, Vol={volatility:.6f}, Mom={momentum:.3f}, Surge={volume_surge}")
                    
                    # REMOVED VOLATILITY FILTER - Generate signals for ANY volatility!
                    # Original filter was: if volatility < self.min_volatility: continue
                    
                    # Generate trading signal
                    signal = self._generate_signal(
                        symbol, current_price, volatility, 
                        volume_surge, momentum
                    )
                    
                    if signal:
                        signals.append(signal)
                        logger.info(f"  ‚úÖ {symbol}: Generated {signal.action.upper()} signal (confidence: {signal.confidence:.3f})")
                    else:
                        logger.info(f"  ‚ùå {symbol}: No signal generated (signal was None)")
                        
                except Exception as e:
                    logger.error(f"Error scanning {symbol}: {e}")
                    _metric_inc(SCANNER_ERROR_COUNTER)

        logger.info(f"üéØ Total signals generated: {len(signals)}")
        # Sort by best opportunities (high volatility + volume surge)
        top_signals = sorted(signals, key=lambda s: s.confidence, reverse=True)[:10]
        _metric_set(SCANNER_SIGNALS_GAUGE, float(len(top_signals)))
        return top_signals
    
    def _generate_signal(self, symbol: str, price: float, volatility: float, 
                        volume_surge: bool, momentum: float) -> Optional[CryptoSignal]:
        """Generate trading signal based on analysis"""
        
        # ULTRA AGGRESSIVE scalping thresholds for crypto
        high_momentum_threshold = 0.55     # Very low threshold for more trades
        low_momentum_threshold = 0.45      # Very tight range for more opportunities
        high_volatility_threshold = 0.001  # 0.1% instead of 1% (10x more aggressive)
        
        # Determine action
        action = 'hold'
        confidence = 0.0
        target_profit = 0.005  # Default 0.5% profit target
        stop_loss = 0.003      # Default 0.3% stop loss
        
        # High volatility + momentum signals
        if volatility > high_volatility_threshold:
            target_profit = 0.008  # 0.8% profit for high volatility
            stop_loss = 0.005      # 0.5% stop loss
            
            if momentum > high_momentum_threshold:
                action = 'buy'
                confidence = min(0.9, volatility * 10 + (0.3 if volume_surge else 0))
            elif momentum < low_momentum_threshold:
                action = 'sell'
                confidence = min(0.9, volatility * 10 + (0.3 if volume_surge else 0))
        
        # ULTRA AGGRESSIVE volatility signals - REMOVED volatility requirement entirely!
        elif True:  # Always generate signals regardless of volatility!
            if momentum > 0.52 and volume_surge:  # Much lower threshold
                action = 'buy'
                confidence = 0.9  # Even higher confidence
            elif momentum < 0.48 and volume_surge:  # Much tighter range
                action = 'sell'
                confidence = 0.9  # Even higher confidence
            # Add signals without volume surge requirement (VERY AGGRESSIVE)
            elif momentum > 0.52:  # Any momentum above neutral
                action = 'buy'
                confidence = 0.8  # Higher confidence
            elif momentum < 0.48:  # Any momentum below neutral
                action = 'sell'
                confidence = 0.8  # Higher confidence
            # EVEN MORE AGGRESSIVE: Generate signals for ANY momentum deviation
            elif momentum > 0.51:  # TINY deviation above neutral
                action = 'buy'
                confidence = 0.7
            elif momentum < 0.49:  # TINY deviation below neutral
                action = 'sell'
                confidence = 0.7
        
        # ULTRA AGGRESSIVE volume surge signals
        if volume_surge and action == 'hold':
            if momentum > 0.51:  # Almost any bullish momentum
                action = 'buy'
                confidence = 0.9     # Very high confidence
                target_profit = 0.004  # Quick 0.4% target
                stop_loss = 0.002      # Tight 0.2% stop
            elif momentum < 0.49:    # Almost any bearish momentum
                action = 'sell'
                confidence = 0.9     # Very high confidence
                target_profit = 0.004
                stop_loss = 0.002
        
        # MAXIMUM AGGRESSION: Generate signals for ANY price movement!
        if action == 'hold':  # No volatility requirement - trade everything!
            if momentum > 0.505:  # ULTRA minimal bullish momentum (0.5% above neutral)
                action = 'buy'
                confidence = 0.9   # Very high confidence for maximum execution
                target_profit = 0.003
                stop_loss = 0.0015
            elif momentum < 0.495:  # ULTRA minimal bearish momentum (0.5% below neutral)
                action = 'sell'
                confidence = 0.9   # Very high confidence for maximum execution
                target_profit = 0.003
                stop_loss = 0.0015
            # FINAL FALLBACK: If absolutely no momentum, still try to trade on volatility
            elif volatility > 0.0001:  # ANY volatility at all
                import random
                action = 'buy' if random.random() > 0.5 else 'sell'  # Random direction
                confidence = 0.6  # Medium confidence for fallback trades
                target_profit = 0.002
                stop_loss = 0.001
        
        # ULTRA AGGRESSIVE: Accept ANY signal with ANY confidence > 0.01 (1%)
        if action != 'hold' and confidence > 0.01:  # EXTREMELY LOW threshold - almost any signal
            logger.info(f"    üéØ Creating signal: {action.upper()} {symbol} conf={confidence:.3f} vol={volatility:.6f}")
            return CryptoSignal(
                symbol=symbol,
                action=action,
                confidence=confidence,
                price=price,
                volatility=volatility,
                volume_surge=volume_surge,
                momentum=momentum,
                target_profit=target_profit,
                stop_loss=stop_loss,
                timestamp=datetime.now()
            )
        else:
            logger.info(f"    ‚ùå Signal rejected: action={action}, confidence={confidence:.3f} (< 0.01)")
        
        return None
    
    def update_market_data(self, symbol: str, price: float, volume: float):
        """Update real-time market data"""
        with self.lock:
            if symbol not in self.price_data:
                self.price_data[symbol] = []
                self.volume_data[symbol] = []
            
            self.price_data[symbol].append(price)
            self.volume_data[symbol].append(volume)
            
            # Keep only recent data (1000 data points ‚âà 16-17 hours of 1-min data)
            if len(self.price_data[symbol]) > 1000:
                self.price_data[symbol] = self.price_data[symbol][-1000:]
                self.volume_data[symbol] = self.volume_data[symbol][-1000:]

class CryptoDayTradingBot:
    CASH_SAFETY_BUFFER = Decimal('0.995')
    DEFAULT_TICK_SIZE = Decimal('0.000001')
    TICK_SIZE_BY_SYMBOL = {
        'BTC': Decimal('0.000001'),  # 1e-6 BTC
        'ETH': Decimal('0.0001'),    # 1e-4 ETH
    }
    """High-frequency crypto day trading bot with comprehensive error handling"""
    
    def __init__(
        self,
        alpaca_client,
        initial_capital: float = 10000,
        scanner_config: Optional[CryptoScannerConfig] = None,
        enabled_symbols: Optional[List[str]] = None,
    ):
        self.alpaca = alpaca_client
        self.scanner = CryptoVolatilityScanner(scanner_config, enabled_symbols=enabled_symbols)
        self.initial_capital = initial_capital
        self.max_position_size = min(100, initial_capital * 0.01)  # 1% per trade, max $100
        self.max_concurrent_positions = 10
        self.min_profit_target = 0.003  # 0.3% minimum profit
        
        # Trading metrics
        self.active_positions = {}
        self.daily_trades = 0
        self.daily_profit = 0.0
        self.win_rate = 0.0
        self.total_trades = 0
        self.wins = 0
        
        # Risk management
        self.max_daily_loss = initial_capital * 0.02  # 2% daily loss limit
        self.max_drawdown = initial_capital * 0.05    # 5% maximum drawdown
        
        # Error handling
        self.error_count = 0
        self.max_errors = 10
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 5
        self.rate_limit_errors = 0
        self.last_rate_limit_time = None
        
        # Trade logging
        self.trade_log: List[TradeLog] = []
        self.log_file = 'logs/crypto_trade_timeline.log'
        os.makedirs('logs', exist_ok=True)
        
        self.is_running = False
        self.executor = ThreadPoolExecutor(max_workers=5)

        # Configurable thresholds (can be overridden)
        self.stop_loss_pct = 0.015  # 1.5% stop loss
        self.take_profit_pct = 0.02  # 2% take profit
        self.trailing_stop_pct = 0.01  # 1% trailing stop
        self.max_hold_time_seconds = 3600  # 1 hour max hold

    @property
    def _api(self):
        """Get the raw Alpaca REST API object, handling both wrapper and direct types."""
        # If alpaca has an 'api' attribute (it's a wrapper), use that
        if hasattr(self.alpaca, 'api'):
            return self.alpaca.api
        # If alpaca has a 'get_api' method, use that
        if hasattr(self.alpaca, 'get_api'):
            return self.alpaca.get_api()
        # Otherwise assume it's already the raw API
        return self.alpaca
        
    async def _sync_positions_from_alpaca(self):
        """Sync active_positions with actual Alpaca positions"""
        try:
            positions = self._api.list_positions()
            synced_count = 0

            for pos in positions:
                symbol = pos.symbol
                # Only track crypto positions
                if not symbol.endswith('USD') and not symbol.endswith('USDT'):
                    continue

                if symbol not in self.active_positions:
                    entry_price = float(pos.avg_entry_price)
                    qty = float(pos.qty)
                    side = 'buy' if float(pos.qty) > 0 else 'sell'

                    # Create position entry with default thresholds
                    self.active_positions[symbol] = {
                        'signal': None,  # External position, no signal
                        'entry_price': entry_price,
                        'entry_price_dec': Decimal(str(entry_price)),
                        'quantity': abs(qty),
                        'quantity_dec': Decimal(str(abs(qty))),
                        'side': side,
                        'entry_time': datetime.now(),  # Approximate
                        'target_price': entry_price * (1 + self.take_profit_pct) if side == 'buy' else entry_price * (1 - self.take_profit_pct),
                        'stop_price': entry_price * (1 - self.stop_loss_pct) if side == 'buy' else entry_price * (1 + self.stop_loss_pct),
                        'order_id': None,
                        'synced_from_alpaca': True,
                        'unrealized_pnl': float(pos.unrealized_pl) if hasattr(pos, 'unrealized_pl') else 0,
                        'current_price': float(pos.current_price) if hasattr(pos, 'current_price') else entry_price
                    }
                    synced_count += 1
                    logger.info(f"üì• Synced existing position: {symbol} | Entry: ${entry_price:.4f} | Qty: {qty}")

            # Remove positions that no longer exist on Alpaca
            alpaca_symbols = {pos.symbol for pos in positions}
            to_remove = [s for s in self.active_positions if s not in alpaca_symbols]
            for symbol in to_remove:
                del self.active_positions[symbol]
                logger.info(f"üì§ Removed closed position from tracking: {symbol}")

            if synced_count > 0:
                logger.info(f"‚úÖ Synced {synced_count} positions from Alpaca. Total tracked: {len(self.active_positions)}")

        except Exception as e:
            logger.error(f"Failed to sync positions from Alpaca: {e}")

    async def start_trading(self):
        """Start the day trading bot"""
        logger.info("üöÄ Starting Crypto Day Trading Bot")
        self.is_running = True

        # Sync existing positions from Alpaca first
        await self._sync_positions_from_alpaca()

        # Start market data feed
        self.executor.submit(self._start_market_data_feed)

        # Main trading loop
        while self.is_running:
            try:
                await self._trading_cycle()
                await asyncio.sleep(1)  # 1-second cycle for high frequency
                
            except Exception as e:
                logger.error(f"Trading cycle error: {e}")
                await asyncio.sleep(5)
    
    async def _trading_cycle(self):
        """Main trading cycle - runs every second"""

        # Check for exit signals on existing positions
        await self._check_exit_conditions()

        # Sync positions from Alpaca every 30 seconds to catch external changes
        if int(time.time()) % 30 == 0:
            await self._sync_positions_from_alpaca()

        # Look for new entry opportunities every 10 seconds (aligned with data polling)
        if int(time.time()) % 10 == 0:
            await self._find_entry_opportunities()

        # Update metrics every minute
        if int(time.time()) % 60 == 0:
            self._update_metrics()
    
    async def _find_entry_opportunities(self):
        """Find new trading opportunities"""
        if len(self.active_positions) >= self.max_concurrent_positions:
            return
        
        if abs(self.daily_profit) > self.max_daily_loss:
            logger.warning("Daily loss limit reached, stopping new trades")
            return
        
        # Get trading signals
        signals = self.scanner.scan_for_opportunities()
        
        for signal in signals[:5]:  # Top 5 opportunities
            if signal.symbol in self.active_positions:
                continue
            
            if signal.confidence > 0.7:  # High confidence trades only
                await self._execute_entry(signal)
    
    async def _execute_entry(self, signal: CryptoSignal):
        """Execute entry trade with comprehensive error handling and logging"""
        start_time = time.time()
        trade_log = TradeLog(
            timestamp=datetime.now().isoformat(),
            action=signal.action.upper(),
            symbol=signal.symbol,
            quantity=0,
            price=signal.price,
            status="pending",
            error_notes=""
        )

        try:
            # IMPORTANT: Skip SELL signals (no short selling in crypto)
            # Only execute BUY signals
            if signal.action.lower() == 'sell':
                logger.info(f"‚è≠Ô∏è  Skipping SELL signal for {signal.symbol} (no short selling)")
                return

            # Calculate position size - ensure minimum $10 order size
            position_value = max(
                10.0,  # Alpaca minimum
                min(self.max_position_size, 25 * signal.confidence)  # Max $25 per trade
            )

            # Clamp against available funds with a safety margin
            try:
                account = self._api.get_account()
                available_cash = float(getattr(account, 'cash', getattr(account, 'buying_power', 0.0)))
            except Exception as exc:
                logger.warning(f"Unable to fetch account balance, defaulting to configured limits: {exc}")
                available_cash = position_value

            quantity = self._calculate_affordable_quantity(
                price=signal.price,
                desired_notional=position_value,
                available_cash=available_cash,
                symbol=signal.symbol,
            )

            if quantity <= 0:
                logger.warning("Calculated crypto quantity is 0 after precision clamp")
                return

            quantity_dec = quantity if isinstance(quantity, Decimal) else Decimal(str(quantity))
            quantity_float = float(quantity_dec)
            price_dec = Decimal(str(signal.price))

            trade_log.quantity = quantity_float

            # Place order with error handling
            order = await self._place_crypto_order_with_retry(
                symbol=signal.symbol,
                side=signal.action,
                quantity=quantity_float,
                order_type='market'
            )

            if order:
                # Track position
                self.active_positions[signal.symbol] = {
                    'signal': signal,
                    'entry_price': signal.price,
                    'entry_price_dec': price_dec,
                    'quantity': quantity_float,
                    'quantity_dec': quantity_dec,
                    'side': signal.action,
                    'entry_time': datetime.now(),
                    'target_price': signal.price * (1 + signal.target_profit) if signal.action == 'buy' else signal.price * (1 - signal.target_profit),
                    'stop_price': signal.price * (1 - signal.stop_loss) if signal.action == 'buy' else signal.price * (1 + signal.stop_loss),
                    'order_id': order.id if hasattr(order, 'id') else str(order)
                }
                
                trade_log.status = "filled"
                trade_log.order_id = order.id if hasattr(order, 'id') else str(order)
                trade_log.execution_time_ms = int((time.time() - start_time) * 1000)
                
                logger.info(f"üéØ Opened {signal.action.upper()} position: {signal.symbol} @ {signal.price:.4f}")
            else:
                trade_log.status = "failed"
                trade_log.error_notes = "Order placement failed"
        
        except APIError as e:
            trade_log.status = "failed"
            if hasattr(e, 'code'):
                if e.code == 429:
                    trade_log.error_notes = "API rate limit exceeded"
                    self.rate_limit_errors += 1
                    self.last_rate_limit_time = datetime.now()
                    logger.error(f"üö´ Rate limit hit for {signal.symbol}: {e}")
                    await self._handle_rate_limit()
                elif e.code == 403:
                    trade_log.error_notes = "Insufficient funds"
                    logger.error(f"üí∏ Insufficient funds for {signal.symbol}")
                elif e.code == 400:
                    trade_log.error_notes = f"Invalid request: {str(e)}"
                    logger.error(f"‚ùå Invalid request for {signal.symbol}: {e}")
                else:
                    trade_log.error_notes = f"API error {e.code}: {str(e)}"
                    logger.error(f"‚ùå API error for {signal.symbol}: {e}")
            else:
                trade_log.error_notes = f"API error: {str(e)}"
                logger.error(f"‚ùå API error for {signal.symbol}: {e}")
                
        except ConnectionError as e:
            trade_log.status = "failed"
            trade_log.error_notes = "Connection lost, attempting reconnect"
            logger.error(f"üîå Connection error for {signal.symbol}: {e}")
            await self._handle_connection_error()
            
        except Exception as e:
            trade_log.status = "failed"
            trade_log.error_notes = f"Unexpected error: {str(e)}"
            logger.error(f"‚ùå Unexpected error for {signal.symbol}: {e}")
            self.error_count += 1
            
        finally:
            # Log trade to timeline
            trade_log.execution_time_ms = int((time.time() - start_time) * 1000)
            self._log_trade(trade_log)

    @classmethod
    def _crypto_tick_size(cls, symbol: str) -> Decimal:
        base = symbol.split('/')[0].upper() if '/' in symbol else symbol.upper()
        return cls.TICK_SIZE_BY_SYMBOL.get(base, cls.DEFAULT_TICK_SIZE)

    @classmethod
    def _calculate_affordable_quantity(
        cls,
        *,
        price: float,
        desired_notional: float,
        available_cash: float,
        symbol: str,
    ) -> Decimal:
        price_dec = Decimal(str(price))
        desired_dec = Decimal(str(desired_notional))
        available_dec = Decimal(str(available_cash))

        if price_dec <= 0:
            return Decimal('0')

        safe_cash = (available_dec * cls.CASH_SAFETY_BUFFER).quantize(Decimal('0.000000001'), rounding=ROUND_DOWN)
        notional_cap = min(desired_dec, safe_cash)
        if notional_cap <= 0:
            return Decimal('0')

        raw_qty = notional_cap / price_dec
        tick_size = cls._crypto_tick_size(symbol)
        if tick_size <= 0:
            tick_size = cls.DEFAULT_TICK_SIZE

        ticks = (raw_qty / tick_size).to_integral_value(rounding=ROUND_DOWN)
        qty = ticks * tick_size
        if qty < tick_size:
            return Decimal('0')
        return qty
    
    async def _check_exit_conditions(self):
        """Check exit conditions for all active positions"""
        positions_to_close = []

        # Make a copy of items to iterate (avoid dict modification during iteration)
        for symbol, position in list(self.active_positions.items()):
            try:
                # Get current price
                current_price = await self._get_current_price(symbol)
                if not current_price:
                    # Try to get from Alpaca position directly
                    try:
                        alpaca_pos = self._api.get_position(symbol)
                        current_price = float(alpaca_pos.current_price)
                    except Exception:
                        logger.warning(f"Cannot get current price for {symbol}, skipping exit check")
                        continue

                entry_price = position['entry_price']
                side = position['side']

                # Calculate current P&L
                if side == 'buy':
                    pnl_pct = (current_price - entry_price) / entry_price
                else:
                    pnl_pct = (entry_price - current_price) / entry_price

                should_exit = False
                exit_reason = ""

                # Log position status periodically (every ~60 checks = ~1 min)
                if int(time.time()) % 60 == 0:
                    logger.info(f"üìä {symbol}: Entry ${entry_price:.4f} | Current ${current_price:.4f} | P&L: {pnl_pct:.2%} | Stop: ${position['stop_price']:.4f} | Target: ${position['target_price']:.4f}")

                # Profit target hit
                if ((side == 'buy' and current_price >= position['target_price']) or
                    (side == 'sell' and current_price <= position['target_price'])):
                    should_exit = True
                    exit_reason = "PROFIT_TARGET"

                # Stop loss hit
                elif ((side == 'buy' and current_price <= position['stop_price']) or
                      (side == 'sell' and current_price >= position['stop_price'])):
                    should_exit = True
                    exit_reason = "STOP_LOSS"

                # Time-based exit (configurable max hold time)
                elif (datetime.now() - position['entry_time']).total_seconds() > self.max_hold_time_seconds:
                    should_exit = True
                    exit_reason = "TIME_LIMIT"

                # Trailing stop for profitable positions (activate at 1% profit)
                elif pnl_pct > self.trailing_stop_pct:
                    # Implement trailing stop
                    trail_distance = self.trailing_stop_pct * 0.5  # Trail at half the activation threshold
                    if side == 'buy':
                        new_stop = current_price * (1 - trail_distance)
                        if new_stop > position['stop_price']:
                            old_stop = position['stop_price']
                            position['stop_price'] = new_stop
                            logger.info(f"üìà {symbol}: Trailing stop raised from ${old_stop:.4f} to ${new_stop:.4f}")
                    else:
                        new_stop = current_price * (1 + trail_distance)
                        if new_stop < position['stop_price']:
                            old_stop = position['stop_price']
                            position['stop_price'] = new_stop
                            logger.info(f"üìâ {symbol}: Trailing stop lowered from ${old_stop:.4f} to ${new_stop:.4f}")

                if should_exit:
                    logger.info(f"üö® EXIT SIGNAL: {symbol} | Reason: {exit_reason} | P&L: {pnl_pct:.2%}")
                    positions_to_close.append((symbol, exit_reason, current_price, pnl_pct))

            except Exception as e:
                logger.error(f"Error checking exit for {symbol}: {e}", exc_info=True)

        # Close positions
        for symbol, reason, price, pnl_pct in positions_to_close:
            await self._execute_exit(symbol, reason, price, pnl_pct)
    
    async def _execute_exit(self, symbol: str, reason: str, price: float, pnl_pct: float):
        """Execute exit trade"""
        try:
            position = self.active_positions[symbol]
            
            # Place closing order
            opposite_side = 'sell' if position['side'] == 'buy' else 'buy'
            
            order = await self._place_crypto_order(
                symbol=symbol,
                side=opposite_side,
                quantity=position['quantity'],
                order_type='market'
            )
            
            if order:
                # Update metrics
                qty_dec = position.get('quantity_dec')
                if qty_dec is None:
                    qty_dec = Decimal(str(position['quantity']))
                price_dec = position.get('entry_price_dec')
                if price_dec is None:
                    price_dec = Decimal(str(position['entry_price']))
                profit = float(qty_dec * price_dec * Decimal(str(pnl_pct)))
                self.daily_profit += profit
                self.total_trades += 1
                
                if pnl_pct > 0:
                    self.wins += 1
                
                self.win_rate = self.wins / self.total_trades if self.total_trades > 0 else 0
                
                # Remove from active positions
                del self.active_positions[symbol]
                
                logger.info(f"‚úÖ Closed position: {symbol} | Reason: {reason} | P&L: {pnl_pct:.2%} | Profit: ${profit:.2f}")
        
        except Exception as e:
            logger.error(f"Failed to execute exit for {symbol}: {e}")
    
    async def _place_crypto_order(self, symbol: str, side: str, quantity: float, order_type: str = 'market'):
        """Place crypto order via Alpaca API"""
        try:
            # Convert symbol format if needed (BTC/USD -> BTCUSD)
            alpaca_symbol = symbol.replace('/', '')

            # Import order request classes
            from alpaca.trading.requests import MarketOrderRequest
            from alpaca.trading.enums import OrderSide, TimeInForce

            # Convert side to enum
            order_side = OrderSide.BUY if side.lower() == 'buy' else OrderSide.SELL

            # Create market order request
            order_request = MarketOrderRequest(
                symbol=alpaca_symbol,
                qty=quantity,
                side=order_side,
                time_in_force=TimeInForce.IOC  # Immediate or cancel for crypto
            )

            # Submit order using Alpaca client
            order = self._api.submit_order(order_data=order_request)
            return order

        except Exception as e:
            logger.error(f"Order placement failed for {symbol}: {e}")
            return None
    
    async def _place_crypto_order_with_retry(self, symbol: str, side: str, quantity: float, order_type: str = 'market', max_retries: int = 3):
        """Place crypto order with retry logic for transient failures"""
        for attempt in range(max_retries):
            try:
                order = await self._place_crypto_order(symbol, side, quantity, order_type)
                if order:
                    return order
                    
            except APIError as e:
                if hasattr(e, 'code') and e.code == 429:
                    # Rate limit - wait longer
                    wait_time = min(60, 2 ** attempt * 5)
                    logger.warning(f"Rate limit hit, waiting {wait_time}s before retry")
                    await asyncio.sleep(wait_time)
                elif attempt < max_retries - 1:
                    # Other API errors - exponential backoff
                    wait_time = 2 ** attempt
                    logger.warning(f"Retrying order after {wait_time}s (attempt {attempt + 1}/{max_retries})")
                    await asyncio.sleep(wait_time)
                else:
                    raise
                    
            except ConnectionError as e:
                if attempt < max_retries - 1:
                    wait_time = 2 ** attempt
                    logger.warning(f"Connection error, retrying after {wait_time}s")
                    await asyncio.sleep(wait_time)
                else:
                    raise
                    
        return None
    
    async def _handle_rate_limit(self):
        """Handle API rate limit errors with exponential backoff"""
        if self.rate_limit_errors > 5:
            logger.critical("Too many rate limit errors, pausing trading for 5 minutes")
            await asyncio.sleep(300)  # 5 minutes
            self.rate_limit_errors = 0
        else:
            wait_time = min(60, 2 ** self.rate_limit_errors)
            logger.warning(f"Rate limit: waiting {wait_time} seconds")
            await asyncio.sleep(wait_time)
    
    async def _handle_connection_error(self):
        """Handle connection errors with reconnection logic"""
        self.reconnect_attempts += 1
        
        if self.reconnect_attempts > self.max_reconnect_attempts:
            logger.critical("Max reconnection attempts reached, stopping bot")
            self.is_running = False
            return
        
        wait_time = min(60, 2 ** self.reconnect_attempts)
        logger.info(f"Reconnecting in {wait_time} seconds (attempt {self.reconnect_attempts})")
        await asyncio.sleep(wait_time)
        
        # Reset on successful operations
        self.reconnect_attempts = 0
    
    def get_status(self) -> dict:
        """Get comprehensive bot status for dashboard/API"""
        positions_status = []
        total_unrealized_pnl = 0.0

        for symbol, pos in self.active_positions.items():
            try:
                # Try to get current price
                current_price = None
                try:
                    alpaca_pos = self._api.get_position(symbol)
                    current_price = float(alpaca_pos.current_price)
                    unrealized_pnl = float(alpaca_pos.unrealized_pl)
                except Exception:
                    current_price = pos.get('current_price', pos['entry_price'])
                    entry_val = pos['entry_price'] * pos['quantity']
                    current_val = current_price * pos['quantity']
                    unrealized_pnl = current_val - entry_val if pos['side'] == 'buy' else entry_val - current_val

                pnl_pct = (current_price - pos['entry_price']) / pos['entry_price'] if pos['side'] == 'buy' else (pos['entry_price'] - current_price) / pos['entry_price']
                total_unrealized_pnl += unrealized_pnl

                positions_status.append({
                    'symbol': symbol,
                    'side': pos['side'],
                    'entry_price': pos['entry_price'],
                    'current_price': current_price,
                    'quantity': pos['quantity'],
                    'stop_price': pos['stop_price'],
                    'target_price': pos['target_price'],
                    'pnl_pct': round(pnl_pct * 100, 2),
                    'unrealized_pnl': round(unrealized_pnl, 2),
                    'entry_time': pos['entry_time'].isoformat() if isinstance(pos['entry_time'], datetime) else str(pos['entry_time']),
                    'hold_time_seconds': int((datetime.now() - pos['entry_time']).total_seconds()) if isinstance(pos['entry_time'], datetime) else 0,
                    'synced_from_alpaca': pos.get('synced_from_alpaca', False)
                })
            except Exception as e:
                logger.error(f"Error getting status for {symbol}: {e}")

        return {
            'is_running': self.is_running,
            'active_positions_count': len(self.active_positions),
            'max_concurrent_positions': self.max_concurrent_positions,
            'daily_trades': self.daily_trades,
            'total_trades': self.total_trades,
            'daily_profit': round(self.daily_profit, 2),
            'total_unrealized_pnl': round(total_unrealized_pnl, 2),
            'win_rate': round(self.win_rate * 100, 2),
            'wins': self.wins,
            'error_count': self.error_count,
            'thresholds': {
                'stop_loss_pct': self.stop_loss_pct,
                'take_profit_pct': self.take_profit_pct,
                'trailing_stop_pct': self.trailing_stop_pct,
                'max_hold_time_seconds': self.max_hold_time_seconds
            },
            'positions': positions_status
        }

    def _log_trade(self, trade_log: TradeLog):
        """Log trade to console and file with timeline format"""
        # Add to in-memory log
        self.trade_log.append(trade_log)

        # Print to console with formatting
        print(trade_log.to_console_string())

        # Write to file as JSON for analysis
        try:
            with open(self.log_file, 'a') as f:
                # Convert to dict and handle UUID serialization
                trade_dict = asdict(trade_log)
                # Convert UUID to string if present
                if 'order_id' in trade_dict and trade_dict['order_id']:
                    trade_dict['order_id'] = str(trade_dict['order_id'])
                f.write(json.dumps(trade_dict) + '\n')
        except Exception as e:
            logger.error(f"Failed to write trade log to file: {e}")
        
        # Update metrics
        if trade_log.status == "filled":
            self.daily_trades += 1
            self.total_trades += 1
            try:
                TradeStore.record_trade(
                    symbol=trade_log.symbol,
                    side=trade_log.action.lower(),
                    qty=trade_log.quantity,
                    price=trade_log.price,
                    pnl=trade_log.pnl,
                    order_id=trade_log.order_id or None,
                    timestamp=trade_log.timestamp,
                )
            except Exception as exc:
                logger.error("Failed to persist trade log: %s", exc)
    
    async def _get_current_price(self, symbol: str) -> Optional[float]:
        """Get current price for symbol"""
        try:
            # Get from price data
            with self.scanner.lock:
                if symbol in self.scanner.price_data and self.scanner.price_data[symbol]:
                    return self.scanner.price_data[symbol][-1]
            return None
        except:
            return None
    
    def _start_market_data_feed(self):
        """Start polling feed for real market data"""
        import threading
        from alpaca_trade_api.rest import TimeFrame

        def poll_market_data():
            logger.info("üì° Starting real market data polling...")
            
            # Initial history fetch (last 60 mins) to build volatility baseline
            try:
                symbols = self.scanner.get_enabled_symbols()
                if symbols:
                    end = datetime.now()
                    start = end - timedelta(minutes=60)
                    # Convert to date strings (YYYY-MM-DD) for Alpaca API compatibility
                    start_str = start.strftime('%Y-%m-%d')
                    end_str = end.strftime('%Y-%m-%d')
                    for symbol in symbols:
                        try:
                            # Convert BTCUSD to BTC/USD for Alpaca API 
                            if '/' not in symbol:
                                api_symbol = symbol[:-3] + '/' + symbol[-3:]  # BTC + USD -> BTC/USD
                            else:
                                api_symbol = symbol
                            bars = self._api.get_crypto_bars(
                                api_symbol, 
                                TimeFrame.Minute,
                                start=start_str,
                                end=end_str
                            ).df
                            
                            if not bars.empty:
                                for index, row in bars.iterrows():
                                    # Store with original symbol format (BTCUSD) or normalized  
                                    self.scanner.update_market_data(
                                        symbol, 
                                        float(row['close']), 
                                        float(row['volume'])
                                    )
                            logger.info(f"  Loaded {len(bars)} historical bars for {formatted_symbol}")
                        except Exception as e:
                            logger.error(f"Failed to load history for {symbol}: {e}")
            except Exception as e:
                logger.error(f"Initial data fetch failed: {e}")

            # Main polling loop
            while self.is_running:
                try:
                    symbols = self.scanner.get_enabled_symbols()
                    if not symbols:
                        time.sleep(5)
                        continue

                    # Poll for latest data every 30 seconds (Alpaca crypto bars are 1 min typically, 
                    # but we want to catch them as soon as they close or update)
                    # Note: get_crypto_bars returns 1Min bars. For real-time 'tick' data we'd need websocket.
                    # For scalping, 1Min bars are acceptable if we poll frequently to get the latest completed bar.
                    
                    end = datetime.now()
                    start = end - timedelta(minutes=5) # Get last few bars to ensure continuity
                    # Convert to date strings for Alpaca API compatibility
                    start_str = start.strftime('%Y-%m-%d')
                    end_str = end.strftime('%Y-%m-%d')
                    
                    for symbol in symbols:
                        try:
                            # Convert BTCUSD to BTC/USD for Alpaca API
                            if '/' not in symbol:
                                api_symbol = symbol[:-3] + '/' + symbol[-3:]  # BTC + USD -> BTC/USD
                            else:
                                api_symbol = symbol
                            bars = self._api.get_crypto_bars(
                                api_symbol, 
                                TimeFrame.Minute,
                                start=start_str,
                                end=end_str
                            ).df
                            
                            if not bars.empty:
                                # Update with latest bar - store with original symbol format
                                latest = bars.iloc[-1]
                                self.scanner.update_market_data(
                                    symbol, 
                                    float(latest['close']), 
                                    float(latest['volume'])
                                )
                                logger.debug(f"Updated {symbol}: ${latest['close']:.2f} Vol:{latest['volume']:.0f}")
                        except Exception as e:
                            # Log rate limits specifically
                            if "429" in str(e):
                                logger.warning(f"Rate limit during polling {symbol}, slowing down...")
                                time.sleep(1)
                            else:
                                logger.debug(f"Polling error for {symbol}: {e}")
                                
                    time.sleep(10)  # Poll every 10 seconds

                except Exception as e:
                    logger.error(f"Market data polling error: {e}")
                    time.sleep(10)
        
        threading.Thread(target=poll_market_data, daemon=True).start()
        logger.info("üìä Real market data polling started")
    
    def _update_metrics(self):
        """Update trading metrics"""
        current_time = datetime.now()
        
        # Reset daily metrics at midnight
        if current_time.hour == 0 and current_time.minute == 0:
            self.daily_trades = 0
            self.daily_profit = 0.0
        
        logger.info(f"üìà Metrics: Active Positions: {len(self.active_positions)} | "
                   f"Daily P&L: ${self.daily_profit:.2f} | Win Rate: {self.win_rate:.1%} | "
                   f"Total Trades: {self.total_trades}")
    
    def get_status(self) -> Dict:
        """Get current bot status"""
        return {
            'is_running': self.is_running,
            'bot_running': self.is_running,  # For frontend compatibility
            'active_positions': len(self.active_positions),
            'daily_profit': self.daily_profit,
            'daily_trades': self.daily_trades,
            'win_rate': self.win_rate,
            'total_trades': self.total_trades,
            'positions': list(self.active_positions.keys()),
            'error_count': self.error_count,
            'rate_limit_errors': self.rate_limit_errors,
            'recent_trades': len(self.trade_log)
        }
    
    def print_trade_timeline(self, last_n: int = 20):
        """Print formatted trade timeline to console"""
        print("\n" + "="*100)
        print("üìä TRADE TIMELINE (Last {} Trades)".format(min(last_n, len(self.trade_log))))
        print("="*100)
        
        if not self.trade_log:
            print("No trades executed yet")
        else:
            # Print header
            print(f"{'Time':<20} {'Action':<6} {'Symbol':<10} {'Qty':<10} {'Price':<12} {'Status':<15} {'P&L':<10} {'Notes'}")
            print("-"*100)
            
            # Print recent trades
            for trade in self.trade_log[-last_n:]:
                print(trade.to_console_string())
        
        # Print summary statistics
        print("\n" + "="*100)
        print("üìà TRADING SUMMARY")
        print("-"*100)
        
        filled_trades = [t for t in self.trade_log if t.status == "filled"]
        failed_trades = [t for t in self.trade_log if t.status == "failed"]
        
        print(f"Total Trades Attempted: {len(self.trade_log)}")
        print(f"Successful Trades: {len(filled_trades)}")
        print(f"Failed Trades: {len(failed_trades)}")
        
        if filled_trades:
            total_pnl = sum(t.pnl for t in filled_trades)
            avg_exec_time = sum(t.execution_time_ms for t in filled_trades) / len(filled_trades)
            print(f"Total P&L: ${total_pnl:+,.2f}")
            print(f"Average Execution Time: {avg_exec_time:.0f}ms")
        
        if failed_trades:
            print("\n‚ö†Ô∏è ERROR SUMMARY:")
            error_counts = {}
            for trade in failed_trades:
                error = trade.error_notes.split(':')[0] if trade.error_notes else "Unknown"
                error_counts[error] = error_counts.get(error, 0) + 1
            
            for error, count in sorted(error_counts.items(), key=lambda x: x[1], reverse=True):
                print(f"  {error}: {count} occurrences")
        
        print("="*100 + "\n")
    
    def stop(self):
        """Stop the trading bot and print final summary"""
        logger.info("üõë Stopping Crypto Day Trading Bot")
        self.is_running = False
        self.executor.shutdown(wait=True)
        
        # Print final trade timeline
        self.print_trade_timeline(last_n=50)

# Integration function for the main bot
def create_crypto_day_trader(alpaca_client, config: TradingConfig) -> CryptoDayTradingBot:
    """Create and configure crypto day trading bot."""

    bot = CryptoDayTradingBot(
        alpaca_client,
        config.investment_amount,
        scanner_config=config.crypto_scanner,
        enabled_symbols=config.symbols,
    )

    risk_settings = config.risk_management
    position_ratio = risk_settings.max_position_size or 0.05
    bot.max_position_size = config.investment_amount * position_ratio
    bot.max_concurrent_positions = config.max_trades_active
    bot.min_profit_target = 0.003
    bot.max_daily_loss = config.investment_amount * (risk_settings.max_daily_loss or 0.02)

    logger.info(
        "Crypto day trader configured with %d scanner symbols (defaults merged with overrides)",
        len(bot.scanner.get_enabled_symbols()),
    )

    return bot
